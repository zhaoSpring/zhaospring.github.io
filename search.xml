<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>从0开始编写mcp client</title>
    <url>/2025/06/10/mcp-client/</url>
    <content><![CDATA[<p>Test content</p>
]]></content>
      <categories>
        <category>ai</category>
      </categories>
      <tags>
        <tag>ai</tag>
      </tags>
  </entry>
  <entry>
    <title>px、dp理解</title>
    <url>/2025/05/13/px%E3%80%81dp%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>最近使用<code>px</code>、<code>dp</code>有点感悟，记录一下~</p>
<h1>px</h1>
<p><code>px</code>是像素（<code>pixel</code>）的缩写，是屏幕像素的基本单位。</p>
<ul>
<li><code>1px</code>代表屏幕上的一个物理像素点。</li>
<li>在不同设备上，<code>1px</code>的实际显示大小是不一样的，这取决于设备的<strong>像素密度</strong>。</li>
</ul>
<p>如下图所示（图片来自<a href="http://developer.android.com/guide/practices/screens_support.html?spm=a2c6h.12873639.article-detail.5.66807717aqjkBd">android developer guide</a>），两款尺寸相同的手机，但是像素密度不同，导致显示的<code>1px</code>大小也不同。</p>
<p align = "center">    
<img  src="px-dp-1.png" width="400" />
</p>
<p><code>px</code>不建议直接使用，因为同为<code>100px</code>的图片，在不同手机上显示的实际大小可能不同，如下图所示：</p>
<p><img src="px-dp-2.png" alt=""></p>
<p>但也有一些特殊的场景需要用到<code>px</code>，例如：需要画1像素表格线或阴影线的时候，用其他单位如dp会显得模糊</p>
<h1>dpi/ppi</h1>
<p><code>dpi</code>和<code>ppi</code>都能表示<strong>像素密度</strong>，但它们的含义略有不同：</p>
<ul>
<li><code>dpi</code>：表示水平或垂直方向每英寸的像素数</li>
<li><code>ppi</code>：表示沿对角线方向每英寸长度的像素数</li>
</ul>
<h1>dp</h1>
<p><code>dp</code>是独立像素密度（<code>density-independent pixel</code>）的缩写，是 <code>Android</code> 中常用的一个单位，也叫 <code>dip</code>。</p>
<ul>
<li><code>dp</code> 是一个与设备屏幕密度无关的抽象单位。</li>
<li><code>dp</code>单位的目的是让 UI 在不同分辨率和密度的设备上具有一致的显示效果。</li>
<li>在 <code>160dpi</code>（即基准密度）的屏幕上，1 <code>dp</code> = 1 <code>px</code>。</li>
<li>不同密度的设备会自动根据比例将 <code>dp</code> 转换为对应的 <code>px</code>。</li>
</ul>
<p><strong>转化公式：</strong></p>
<p align = "center">    
<img  src="px-dp-3.png" width="200" />
</p>
<p>不同的手机/平板可能具有不同的像素密度，<code>Android</code>系统定义了四种像素密度：低（ <code>120dpi</code>）、中（<code>160dpi</code>）、高（<code>240dpi</code>）和超高（<code>320dpi</code>）。</p>
<p>例如，界面上有一个长度为<code>80dp</code>的图片，那么它在：</p>
<ul>
<li>低密度设备上（<code>120dpi</code>）显示为：<code>80dp * 120dpi / 160dpi = 60px</code></li>
<li>中密度设备上（<code>160dpi</code>）显示为：<code>80dp * 160dpi / 160dpi = 80px</code></li>
<li>高密度设备上（<code>240dpi</code>）显示为：<code>80dp * 240dpi / 160dpi = 120px</code></li>
<li>超高密度设备上（<code>320dpi</code>）显示为：<code>80dp * 320dpi / 160dpi = 160px</code></li>
</ul>
<p>如果你拿这几部手机放在一起对比，会发现这个图片的物理尺寸“差不多”，这就是使用<code>dp</code>作为单位的效果，如下图所示：</p>
<p><img src="px-dp-4.png" alt=""></p>
<p>当需要确保组件在不同设备（如桌面、平板、手机等）上看起来一致时推荐使用<code>dp</code>。</p>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2025/01/01/hello/</url>
    <content><![CDATA[<p>Hello Hexo.</p>
]]></content>
  </entry>
  <entry>
    <title>export和export default的差异</title>
    <url>/2025/01/20/export/</url>
    <content><![CDATA[<h1>总结</h1>
<h2 id="相同">相同</h2>
<ol>
<li>在ES6中，<code>export</code>和<code>export default</code>都可以导出变量、常量、函数、类、模块等；</li>
<li><code>export</code>和<code>export default</code>导出的内容都可以使用<code>import</code>来导入。</li>
</ol>
<h2 id="区别">区别</h2>
<ol>
<li>一个模块可以声明多个<code>export</code>，但只能声明一个<code>export default</code>；</li>
<li><code>export</code>暴露的是一个接口，可以导出多个值；<code>export default</code>暴露的是一个变量，只能导出一个值；</li>
<li>使用<code>export</code>导出时，<code>import</code>需要使用<code>&#123;&#125;</code>；使用<code>export default</code>导出时，<code>import</code>不需要使用<code>&#123;&#125;</code>。</li>
</ol>
<hr>
<h1>export</h1>
<p>要了解<code>export</code>和<code>export default</code>的区别，首先要了解<code>export</code>的基本概念。每个模块都是独立的文件。如果外部模块想要访问模块内部的变量或者或者函数，就必须使用<code>import</code>导入这些内容。<code>export</code>命名规定是<strong>对外的接口</strong>，必须与模块内部的变量一一对应。<br>
<code>export</code>有两种导出方式：</p>
<ol>
<li>具名导出</li>
<li>默认导出（即 <code>default export</code>）</li>
</ol>
<p><strong>一个模块中可以声明多个具名导出<code>export</code>，但是只能有一个默认导出<code>default export</code>。</strong></p>
<h2 id="具名导出">具名导出</h2>
<p><code>export</code>可以直接导出模块内声明的变量、常量、函数、类等，也可以导出模块内声明的其他模块。通常情况下，使用<code>export</code>导出的变量名可以直接使用，如果想要修改变量名可以使用<code>as</code>关键字进行修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一：导出声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1, name2<span class="comment">/*, … */</span>; <span class="comment">// also var</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name1 = <span class="number">1</span>, name2 = <span class="number">2</span><span class="comment">/*, … */</span>; <span class="comment">// also var, let</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params"></span>) &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span>* <span class="title function_">generatorFunctionName</span>(<span class="params"></span>) &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; name1, <span class="attr">name2</span>: bar &#125; = o;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> [ name1, name2 ] = array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：导出列表</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1, <span class="comment">/* …, */</span> nameN &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; variable1 <span class="keyword">as</span> name1, variable2 <span class="keyword">as</span> name2, <span class="comment">/* …, */</span> nameN &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; variable1 <span class="keyword">as</span> <span class="string">&quot;string name&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; name1 <span class="keyword">as</span> <span class="keyword">default</span> <span class="comment">/*, … */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三：导出模块合集</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> name1 <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; name1, <span class="comment">/* …, */</span> nameN &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; import1 <span class="keyword">as</span> name1, import2 <span class="keyword">as</span> name2, <span class="comment">/* …, */</span> nameN &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span>, <span class="comment">/* …, */</span> &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>模块外可以通过<code>import</code>导入<code>export</code>声明的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具名导入：</span></span><br><span class="line"><span class="keyword">import</span> &#123; export1 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 <span class="keyword">as</span> alias1 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1, export2 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1, export2 <span class="keyword">as</span> alias2, <span class="comment">/* … */</span> &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">&quot;string name&quot;</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用<code>import</code>导入时，注意需要使用<code>&#123;&#125;</code>。因为<code>export</code>暴露的是一个接口，可以导出多个值</strong></p>
<hr>
<h1>export default</h1>
<p><code>export</code>还有一种写法，即<code>export default</code>，它用于声明模块的默认导出。一个模块只能有一个默认导出，所以<code>export defalut</code>只能使用一次。</p>
<h2 id="默认导出">默认导出</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法四：默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> expression;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params"></span>) &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>* <span class="title function_">generatorFunctionName</span>(<span class="params"></span>) &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>* () &#123; <span class="comment">/* … */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>模块外可以通过<code>import</code>导入<code>export</code>声明的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认导入：</span></span><br><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用<code>import</code>时不需要加<code>&#123;&#125;</code>，因为<code>export default</code>暴露的是一个变量，只导出一个值。</strong></p>
<hr>
<blockquote>
<p>参考：<br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import</a></p>
</blockquote>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>git rebase 与 merge区别</title>
    <url>/2025/06/25/rebase-merge/</url>
    <content><![CDATA[<h2 id="一图概览">一图概览</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>git merge</th>
<th>git rebase</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作本质</td>
<td>创建一个新的合并提交</td>
<td>把你的提交“挪到”目标分支之后</td>
</tr>
<tr>
<td>提交历史</td>
<td>保留分支分叉（图像呈现树状）</td>
<td>线性历史（图像像一条直线）</td>
</tr>
<tr>
<td>是否修改提交历史</td>
<td>否</td>
<td>是（修改提交 ID）</td>
</tr>
<tr>
<td>是否需要强推</td>
<td>通常不需要</td>
<td>是（如果之前 push 过，rebase 后需 -f）</td>
</tr>
<tr>
<td>冲突处理方式</td>
<td>一次性解决合并冲突</td>
<td>每一个提交可能触发冲突，逐个解决</td>
</tr>
<tr>
<td>合并记录</td>
<td>有合并 commit（如 “Merge branch…”）</td>
<td>没有合并记录，提交像是直接在主干上产生的</td>
</tr>
</tbody>
</table>
<h2 id="示例对比">示例对比</h2>
<h3 id="1-git-merge-的效果">1. git merge 的效果</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge feature</span><br></pre></td></tr></table></figure>
<p>图示：<br>
原始：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A---B---C  (main)</span><br><span class="line">     \</span><br><span class="line">      D---E  (feature)</span><br></pre></td></tr></table></figure>
<p>merge 后：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A---B---C--------M  (main)</span><br><span class="line">     \        /</span><br><span class="line">      D------E</span><br></pre></td></tr></table></figure>
<p>多了一个 M 合并提交。</p>
<h3 id="2-git-rebase-的效果">2. git rebase 的效果</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase main</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<p>原始：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A---B---C  (main)</span><br><span class="line">     \</span><br><span class="line">      D---E  (feature)</span><br></pre></td></tr></table></figure>
<p>rebase 后：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A---B---C---D&#x27;---E&#x27;  (feature)</span><br></pre></td></tr></table></figure>
<p>D 和 E 被“摘下来”并重放到 C 之后。</p>
<h2 id="使用建议">使用建议</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐操作</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>个人开发，准备提交合并请求</td>
<td>rebase</td>
<td>保持提交记录整洁，便于评审</td>
</tr>
<tr>
<td>多人协作，主分支合并 feature 分支</td>
<td>merge</td>
<td>不改历史，不影响他人 pull 的内容</td>
</tr>
<tr>
<td>不关心历史美观，只想快速合并</td>
<td>merge</td>
<td>简单直接</td>
</tr>
<tr>
<td>想清晰回溯每个功能点的开发过程</td>
<td>merge</td>
<td>每个合并点都是功能点</td>
</tr>
<tr>
<td>想让历史看起来像一次性开发完成</td>
<td>rebase</td>
<td>可线性回顾整个演进过程</td>
</tr>
</tbody>
</table>
<h2 id="快速记忆">快速记忆</h2>
<p>merge 是把别人拉进来；rebase 是把自己放到别人后面。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust学习笔记1-变量与数据类型</title>
    <url>/2025/02/10/rust-1/</url>
    <content><![CDATA[<p><img src="rust1-1.png" alt=""></p>
<h2 id="变量">变量</h2>
<ol>
<li>使用 <code>let</code> 关键字声明变量</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">// 不可变变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">10</span>; <span class="comment">// 可变变量</span></span><br><span class="line">    y = <span class="number">11</span>; <span class="comment">// 修改可变变量</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;&quot;</span>, x); <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y: &#123;&#125;&quot;</span>, y); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>变量默认<strong>不可变</strong>（immutable），需要修改时必须使用 <code>mut</code> 关键字</li>
<li>变量遮蔽（Shadow）：可以使用相同名称声明新变量，即第一个变量被第二个变量遮蔽（Shadow）</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>; <span class="comment">// 创建新变量，而不是修改原变量</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;&quot;</span>, x); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量">常量</h2>
<ul>
<li>使用 <code>const</code> 关键字声明</li>
<li>必须注明类型</li>
<li>只能是<strong>常量表达式</strong>，不能是函数调用的结果或者运行时计算得到的值</li>
<li>常量命名规则：字母全部大写，使用下划线分隔单词</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="type">u32</span> = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> PI: <span class="type">f64</span> = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> HELLO_WORLD: &amp;<span class="type">str</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> A: <span class="type">char</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h2 id="数据类型">数据类型</h2>
<h3 id="标量类型">标量类型</h3>
<p>标量（scalar）表示单个值，有以下几种：</p>
<ol>
<li>整数类型</li>
</ol>
<ul>
<li>没有小数部分的数字</li>
<li>有符号：<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></li>
<li>无符号：<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></li>
<li>默认类型：<code>i32</code></li>
</ul>
<ol start="2">
<li>浮点数类型</li>
</ol>
<ul>
<li>带小数点的数字</li>
<li><code>f32</code>：单精度</li>
<li><code>f64</code>：双精度（默认类型）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>布尔类型</li>
</ol>
<ul>
<li><code>bool</code>：true 或 false</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>字符类型</li>
</ol>
<ul>
<li><code>char</code>：使用单引号，4个字节，表示 Unicode 字符</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">emoji</span> = <span class="string">&#x27;😻&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="复合类型">复合类型</h3>
<p>复合类型（compound type）可以将多个值组合成一个类型，有以下几种：</p>
<ol>
<li>元组类型</li>
</ol>
<ul>
<li>固定长度，用<code>()</code>表示</li>
<li>可以包含不同类型的值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup; <span class="comment">// 解构</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = tup.<span class="number">0</span>; <span class="comment">// 使用索引访问</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>数组类型</li>
</ol>
<ul>
<li>固定长度，用<code>[]</code>表示</li>
<li>元素类型必须相同</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">// [3, 3, 3, 3, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="类型转换">类型转换</h2>
<ol>
<li>使用 <code>as</code> 关键字进行基本类型转换</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3.14</span> <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;&quot;</span>, a); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>数字之间的类型转换要注意可能的精度损失和溢出</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">256_i32</span> <span class="keyword">as</span> <span class="type">i8</span>; <span class="comment">// 可能溢出</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b: &#123;&#125;&quot;</span>, b); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项">注意事项</h2>
<ol>
<li>Rust 是静态类型语言，编译时必须知道所有变量的类型</li>
<li>大多数情况下编译器可以推断类型</li>
<li>当可能存在多种类型时，必须添加类型注解</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;不是数字！&quot;</span>);</span><br></pre></td></tr></table></figure>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>密码算法RSA、AES的介绍与js实现</title>
    <url>/2025/01/16/rsa-aes/</url>
    <content><![CDATA[<h1>RSA算法</h1>
<p><img src="rsa-aes-1.png" alt=""></p>
<blockquote>
<p>参考：<br>
<a href="https://blog.csdn.net/a745233700/article/details/102341542">https://blog.csdn.net/a745233700/article/details/102341542</a><br>
<a href="https://blog.csdn.net/IT_luosong/article/details/128228961">https://blog.csdn.net/IT_luosong/article/details/128228961</a><br>
<a href="https://www.jianshu.com/p/b32fc387d8ad">https://www.jianshu.com/p/b32fc387d8ad</a></p>
</blockquote>
<h2 id="RSA加密">RSA加密</h2>
<p><img src="rsa-aes-2.png" alt=""><br>
RSA的加密过程可以使用一个通式来表达：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>密文</mtext><mo>=</mo><msup><mtext>明文</mtext><mi>E</mi></msup><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{密文} = \text{明文}^E \pmod N 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">密文</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9146em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">明文</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9146em;"><span style="top:-3.1362em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<p>E、N是RSA加密的密钥，也就是说E和N的组合就是公钥，我们用(E,N)来表示公钥：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>公钥</mtext><mo>=</mo><mo stretchy="false">(</mo><mi>E</mi><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{公钥} = (E, N) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">公钥</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<p>常用<strong>jsrsasign.js</strong>库实现数字签名过程：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公钥（标准的pem格式，含开始标记，结束标记）</span></span><br><span class="line"><span class="keyword">let</span> pk=<span class="string">&quot;-----BEGIN PUBLIC KEY-----\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD3XSdz1MnzazBEN5KOfTx0IyVJ\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Z5wb57isrCuHDhnYXwtmdhQalgII0fozeeFpMpAvlnmHC1kpW7XVGvZnLx3bWbCE\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;bf+pMSW4kmQuI+5cxRUJbCl7sdaODBrINgERHPICVC18AJLThEVMHyjuR6Jn4zQm\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;yYNbReSktY/BrFTvMQIDAQAB\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;-----END PUBLIC KEY-----&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原文</span></span><br><span class="line"><span class="keyword">var</span> src = <span class="string">&quot;好厉害&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="comment">// 读取解析pem格式的公钥, 生成秘钥实例 (RSAKey) </span></span><br><span class="line"><span class="keyword">var</span> pub = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">getKey</span>(pk);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用encrypt方法, 传入明文和公钥实例, 加密后的返回值是16进制字符串.</span></span><br><span class="line"><span class="keyword">var</span> enc = <span class="variable constant_">KJUR</span>.<span class="property">crypto</span>.<span class="property">Cipher</span>.<span class="title function_">encrypt</span>(src,pub);</span><br><span class="line"><span class="comment">// console.log(enc);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果为了方便放在URL上, 建议使用hextob64u(enc)将其转为Base64编码.（它会将+替换成-,/替换成_,去掉尾部补全的=）</span></span><br><span class="line"><span class="comment">// console.log(hextob64(enc));</span></span><br></pre></td></tr></table></figure>
<h2 id="RSA解密">RSA解密</h2>
<p><img src="rsa-aes-3.png" alt=""><br>
RSA的解密同样可以使用一个通式来表达：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>明文</mtext><mo>=</mo><msup><mtext>密文</mtext><mi>D</mi></msup><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{明文} = \text{密文}^D \pmod N 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">明文</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9146em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">密文</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9146em;"><span style="top:-3.1362em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<p>D和N的组合就是私钥：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>私钥</mtext><mo>=</mo><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{私钥} = (D, N) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">私钥</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 私钥</span></span><br><span class="line"> <span class="keyword">let</span> priK = <span class="string">&quot;-----BEGIN PRIVATE KEY-----\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAPddJ3PUyfNrMEQ3\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;ko59PHQjJUlnnBvnuKysK4cOGdhfC2Z2FBqWAgjR+jN54WkykC+WeYcLWSlbtdUa\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;9mcvHdtZsIRt/6kxJbiSZC4j7lzFFQlsKXux1o4MGsg2AREc8gJULXwAktOERUwf\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;KO5HomfjNCbJg1tF5KS1j8GsVO8xAgMBAAECgYEA6eG1JMrj63jEmStmMb1txG1a\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;mu4Q5z2QGgtr2HVXsIIlGEq6tWxyHf7TL4qkuz9onuYKn8n2Eqm44fZtVaBx+5ES\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;zRpIvlTvaxmVu0HZ1hYAzUw1XyRnXNMKpL5tT4GCjm8+QGPzlGxgXI1sNg8r9Jaw\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;9zRUYeA6LQR9RIMkHWUCQQD8QojjVoGjtiunoh/N8iplhUszZIavAEvmDIE+kVy+\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;pA7hvlukLw6JMc7cfTcnHyxDo9iHVIzrWlTuKRq9KWVLAkEA+wgJS2sgtldnCVn6\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;tJKFVwsHrWhMIU29msPPbNuWUD23BcKE/vehIyFu1ahNA/TiM40PEnzprQ5JfPxU\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;16S78wJANTfMLTnYy7Lo7sqTLx2BuD0wqjzw9QZ4/KVytsJv8IAn65P/PVn4FRV+\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;8KEx+3zmF7b/PT2nJRe/hycAzxtmlQJBAMrFwQxEqpXfoAEzx4lY2ZBn/nmaR/SW\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;4VNEXCbocVC7qT1j1R5HVMgV13uKiTtq8dUGWmhqsi7x3XayNK5ECPUCQQDZaAN6\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;tvIHApz9OLsXSw0jZirQ6KEYdharXbIVDy1W1sVE3lzLbqLdFp1bxAHQIvsYS5PM\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;A9veSJh372RLJKkj\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;-----END PRIVATE KEY-----&quot;</span>;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="comment">// 读取解析pem格式的私钥, 生成秘钥实例 (RSAKey) </span></span><br><span class="line"> <span class="keyword">var</span> prv = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">getKey</span>(priK);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 调用encrypt方法, 传入密文和私钥实例进行解密</span></span><br><span class="line"> <span class="keyword">var</span> dec = <span class="variable constant_">KJUR</span>.<span class="property">crypto</span>.<span class="property">Cipher</span>.<span class="title function_">decrypt</span>(enc,prv);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;jsrsasign decrypt: &quot;</span>+dec);</span><br></pre></td></tr></table></figure>
<h2 id="RSA签名">RSA签名</h2>
<p><img src="rsa-aes-4.png" alt=""><br>
RSA生成签名的过程可用下列公式来表述：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>签名</mtext><mo>=</mo><mo stretchy="false">(</mo><mtext>Hash</mtext><mo stretchy="false">(</mo><mtext>明文</mtext><mo stretchy="false">)</mo><msup><mo stretchy="false">)</mo><mi>D</mi></msup><mspace></mspace><mspace width="1em"/><mo stretchy="false">(</mo><mrow><mi mathvariant="normal">m</mi><mi mathvariant="normal">o</mi><mi mathvariant="normal">d</mi></mrow><mspace width="0.3333em"/><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\text{签名} = (\text{Hash}(\text{明文}))^D \pmod N 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord text"><span class="mord cjk_fallback">签名</span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.1413em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord text"><span class="mord">Hash</span></span><span class="mopen">(</span><span class="mord text"><span class="mord cjk_fallback">明文</span></span><span class="mclose">)</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span></span></span></span><span class="mspace allowbreak"></span><span class="mspace" style="margin-right:1em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord"><span class="mord mathrm">mod</span></span></span><span class="mspace" style="margin-right:0.3333em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<blockquote>
<p>Hash函数（摘要算法）：<a href="https://cloud.tencent.com/developer/article/1584742">https://cloud.tencent.com/developer/article/1584742</a></p>
</blockquote>
<p align = "center">    
<img  src="rsa-aes-5.png" width="600" />
</p>
常用**jsrsasign.js库**实现数字签名过程：
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 签名步骤: 先建立 key 对象, 构建 signature 实例, 传入 key 初始化 -&gt; 签名</span></span><br><span class="line"><span class="keyword">var</span> key = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">getKey</span>(priK);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line"><span class="comment">// 创建 Signature 对象，指定Hash算法</span></span><br><span class="line"><span class="keyword">let</span> signature=<span class="keyword">new</span> <span class="variable constant_">KJUR</span>.<span class="property">crypto</span>.<span class="title class_">Signature</span>(&#123;<span class="attr">alg</span>:<span class="string">&quot;SHA1withRSA&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// 传入key实例, 初始化signature实例</span></span><br><span class="line">signature.<span class="title function_">init</span>(key);</span><br><span class="line"><span class="comment">// 传入待签明文</span></span><br><span class="line">signature.<span class="title function_">updateString</span>(src);</span><br><span class="line"><span class="comment">// 签名, 得到16进制字符结果</span></span><br><span class="line"><span class="keyword">let</span> a = signature.<span class="title function_">sign</span>();</span><br><span class="line"><span class="comment">// 如果为了方便放在URL上, 将其转为常用的Base64编码.</span></span><br><span class="line"><span class="keyword">let</span> sign = <span class="title function_">hextob64</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sign);</span><br></pre></td></tr></table></figure>
## RSA验签
![](rsa-aes-6.png)
RSA的签名验证过程可用下列公式来表述：
$$ \text{摘要} = \text{签名}^E \pmod N $$
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验签</span></span><br><span class="line"><span class="comment">// !要重新new 一个Signature, 否则, 取摘要和签名时取得摘要不一样, 导致验签误报失败(原因不明)!</span></span><br><span class="line"><span class="keyword">let</span> signatureVf = <span class="keyword">new</span> <span class="variable constant_">KJUR</span>.<span class="property">crypto</span>.<span class="title class_">Signature</span>(&#123;<span class="attr">alg</span>:<span class="string">&quot;SHA1withRSA&quot;</span>,<span class="attr">prvkeypem</span>:pk&#125;);</span><br><span class="line">signatureVf.<span class="title function_">updateString</span>(src);</span><br><span class="line"><span class="comment">// !接受的参数是16进制字符串!</span></span><br><span class="line"><span class="keyword">let</span> b = signatureVf.<span class="title function_">verify</span>(<span class="title function_">b64tohex</span>(sign));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;jsrsasign verify: &quot;</span>+b);</span><br></pre></td></tr></table></figure>
<h1>AES算法</h1>
<p><img src="rsa-aes-7.png" alt=""></p>
<blockquote>
<p>参考：<br>
密码学——AES/DES加密算法原理介绍 - 枫のBlog<br>
<a href="https://www.cnblogs.com/starwolf/p/3365834.html">https://www.cnblogs.com/starwolf/p/3365834.html</a></p>
</blockquote>
<h2 id="加密标准-模式">加密标准 &amp; 模式</h2>
<p>在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位，如果数据块及密钥长度不足时会补齐。密钥的长度不同，推荐加密轮数也不同，如下表所示：</p>
<table>
<thead>
<tr>
<th>AES</th>
<th>密钥长度（32位比特字）</th>
<th>分组长度(32位比特字)</th>
<th>加密轮数</th>
</tr>
</thead>
<tbody>
<tr>
<td>AES-128</td>
<td>4</td>
<td>4</td>
<td>10</td>
</tr>
<tr>
<td>AES-192</td>
<td>6</td>
<td>4</td>
<td>12</td>
</tr>
<tr>
<td>AES-256</td>
<td>8</td>
<td>4</td>
<td>14</td>
</tr>
</tbody>
</table>
<p>AES加密模式：</p>
<table>
<thead>
<tr>
<th>AES加密模式</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>电码本模式（Electronic Codebook Book (ECB)）</td>
<td>将整个明文分成若干段相同的小段，然后对每一小段进行加密。</td>
</tr>
<tr>
<td>密码分组链接模式（Cipher Block Chaining (CBC)）</td>
<td>先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。</td>
</tr>
<tr>
<td>计算器模式（Counter (CTR)）</td>
<td>计算器模式不常见，在CTR模式中，有一个自增的算子，这个算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密。这种加密方式简单快速，安全可靠，而且可以并行加密，但是在计算器不能维持很长的情况下，密钥只能使用一次。</td>
</tr>
<tr>
<td>密码反馈模式（Cipher FeedBack (CFB)）</td>
<td>这种模式较复杂</td>
</tr>
<tr>
<td>输出反馈模式（Output FeedBack (OFB)）</td>
<td>这种模式较复杂</td>
</tr>
</tbody>
</table>
<h2 id="加解密流程">加解密流程</h2>
<p>AES加解密主要有以下几步操作，完整的加解密流程是通过循环以下步骤来完成的，具体如下图表示</p>
<ul>
<li>轮密钥加</li>
<li>字节代换</li>
<li>行位移</li>
<li>列混合</li>
</ul>
<blockquote>
<p>具体步骤分析参考：<a href="https://goodapple.top/archives/162">https://goodapple.top/archives/162</a></p>
</blockquote>
<p><img src="rsa-aes-8.png" alt=""></p>
<h2 id="AES加密">AES加密</h2>
<p><img src="rsa-aes-9.png" alt=""><br>
设AES加密函数为E，则 C = E(K, P),其中P为明文，K为密钥，C为密文。也就是说，把明文P和密钥K作为加密函数的参数输入，则加密函数E会输出密文C</p>
<h2 id="AES解密">AES解密</h2>
<p><img src="rsa-aes-10.png" alt=""><br>
设AES解密函数为D，则 P = D(K, C),其中C为密文，K为密钥，P为明文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P<br>
常用<strong>crypto-js库</strong>实现AES加解密过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">CryptoJS</span> <span class="keyword">from</span> <span class="string">&#x27;crypto-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;aaaabbbbccccdddd&#x27;</span><span class="comment">//秘钥</span></span><br><span class="line"><span class="keyword">const</span> iv = <span class="string">&#x27;1234567887654321&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Encrypt</span> (<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(text, <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(key), &#123;</span><br><span class="line">    <span class="attr">iv</span>: <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(iv),<span class="comment">//初始变量</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span>,<span class="comment">//加密模式</span></span><br><span class="line">    <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span><span class="comment">//填充方式</span></span><br><span class="line">  &#125;).<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Decrypt</span> (<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> decrypted = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">decrypt</span>(text, <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(key), &#123;</span><br><span class="line">    <span class="attr">iv</span>: <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(iv),</span><br><span class="line">    <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span>,</span><br><span class="line">    <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> decrypted.<span class="title function_">toString</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title class_">Encrypt</span>,</span><br><span class="line">  <span class="title class_">Decrypt</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="variable constant_">AES</span>.<span class="title class_">Encrypt</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">AES</span>.<span class="title class_">Decrypt</span>(text))</span><br></pre></td></tr></table></figure>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>rust学习笔记2-函数</title>
    <url>/2025/02/10/rust-2/</url>
    <content><![CDATA[<p><img src="rust2-1.png" alt=""></p>
<h2 id="函数定义">函数定义</h2>
<ul>
<li>fn关键字声明函数</li>
<li>函数名使用下划线命名法（蛇形命名法，snake_case）：字母小写，下划线分隔单词</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> &lt;函数名&gt;(&lt;参数: 类型&gt;) &lt;函数体&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + y  <span class="comment">// 无分号，作为返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greet</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;你好, &#123;&#125;!&quot;</span>, name);  <span class="comment">// 无返回值，等同于返回 ()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数参数">函数参数</h2>
<ul>
<li>必须声明每个参数的类型</li>
<li>参数数量是固定的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;和是: &#123;&#125;&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数体的语句和表达式">函数体的语句和表达式</h2>
<ul>
<li>语句：执行操作但不返回值，<strong>语句末尾有<code>;</code></strong></li>
<li>表达式：计算并返回值，<strong>表达式末尾没有<code>;</code></strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expression_example</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>; <span class="comment">// 语句</span></span><br><span class="line">        x + <span class="number">1</span>  <span class="comment">// 表达式，返回 4</span></span><br><span class="line">    &#125;;</span><br><span class="line">    y + <span class="number">2</span> <span class="comment">// 表达式，返回 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数返回值">函数返回值</h2>
<ul>
<li>使用 -&gt; 声明返回类型</li>
<li>隐式返回最后一个表达式的值</li>
<li>也可以使用 return 提前返回指定值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_square</span>(num: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    num * num  <span class="comment">// 隐式返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">check_number</span>(num: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 提前返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">true</span>  <span class="comment">// 隐式返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust学习笔记3-注释</title>
    <url>/2025/02/11/rust-3/</url>
    <content><![CDATA[<h2 id="普通注释">普通注释</h2>
<h3 id="行注释">行注释</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个行注释</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">// 这是一个行尾注释</span></span><br></pre></td></tr></table></figure>
<h3 id="块注释">块注释</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是一个块注释</span></span><br><span class="line"><span class="comment">   可以跨越多行 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 块注释可以</span></span><br><span class="line"><span class="comment">   <span class="comment">/* 嵌套使用 */</span></span></span><br><span class="line"><span class="comment">   非常方便 */</span></span><br></pre></td></tr></table></figure>
<h2 id="文档注释">文档注释</h2>
<h3 id="外部文档注释（-）">外部文档注释（///）</h3>
<p>用于函数、结构体、方法等项的文档：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 计算两个数字的和</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # 参数</span></span><br><span class="line"><span class="comment">/// * `a` - 第一个数字</span></span><br><span class="line"><span class="comment">/// * `b` - 第二个数字</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # 示例</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// let result = add(1, 2);</span></span><br><span class="line"><span class="comment">/// assert_eq!(result, 3);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 表示一个矩形的结构体</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部文档注释（-）">内部文档注释（//!）</h3>
<p>用于模块或包的整体文档：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! # 数学计算模块</span></span><br><span class="line"><span class="comment">//! </span></span><br><span class="line"><span class="comment">//! 这个模块提供了基本的数学计算功能。</span></span><br><span class="line"><span class="comment">//! </span></span><br><span class="line"><span class="comment">//! ## 主要功能：</span></span><br><span class="line"><span class="comment">//! - 基础运算</span></span><br><span class="line"><span class="comment">//! - 几何计算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> math &#123;</span><br><span class="line">    <span class="comment">// 模块内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文档注释格式">文档注释格式</h2>
<h3 id="常用章节标记">常用章节标记</h3>
<ul>
<li><code># Examples</code> - 示例代码</li>
<li><code># Panics</code> - 可能的 panic 情况</li>
<li><code># Errors</code> - 错误处理说明</li>
<li><code># Safety</code> - 安全性说明</li>
<li><code># Arguments</code> - 参数说明</li>
<li><code># Returns</code> - 返回值说明</li>
</ul>
<h3 id="示例">示例</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 将字符串转换为大写</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # Arguments</span></span><br><span class="line"><span class="comment">/// * `text` - 要转换的字符串</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # Returns</span></span><br><span class="line"><span class="comment">/// 转换后的大写字符串</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// let upper = to_uppercase(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">/// assert_eq!(upper, &quot;HELLO&quot;);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # Errors</span></span><br><span class="line"><span class="comment">/// 如果输入不是有效的 UTF-8 字符串，将返回错误</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">to_uppercase</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    text.<span class="title function_ invoke__">to_uppercase</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust学习笔记4-控制流</title>
    <url>/2025/02/11/rust-4/</url>
    <content><![CDATA[<h2 id="if-表达式">if 表达式</h2>
<h3 id="if">if</h3>
<ul>
<li>条件必须是bool值，否则会报错</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;条件为真&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;条件为假&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="else-if">else if</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;数字能被4整除&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;数字能被3整除&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;数字不能被4或3整除&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在-let-语句中使用if">在 let 语句中使用if</h3>
<ul>
<li>if else每个分支返回值类型必须一致</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;; <span class="comment">// 返回值类型相同：i32</span></span><br></pre></td></tr></table></figure>
<h2 id="循环">循环</h2>
<h3 id="loop-循环">loop 循环</h3>
<ul>
<li>使用break停止循环</li>
<li>使用break表达式添加返回值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;永远循环！&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 使用break退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从循环返回值</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;结果是: &#123;&#125;&quot;</span>, result); <span class="comment">// 结果是: 20</span></span><br></pre></td></tr></table></figure>
<h3 id="while-循环">while 循环</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number); <span class="comment">// 3! 2! 1!</span></span><br><span class="line">    number -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-循环">for 循环</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历范围</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;值是: &#123;&#125;&quot;</span>, i); <span class="comment">// 值是: 1 值是: 2 值是: 3 值是: 4 值是: 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;值是: &#123;&#125;&quot;</span>, element); <span class="comment">// 值是: 10 值是: 20 值是: 30 值是: 40 值是: 50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust学习笔记5-所有权</title>
    <url>/2025/02/12/rust-5/</url>
    <content><![CDATA[<h2 id="所有权规则">所有权规则</h2>
<ul>
<li>每个值都有一个变量，称为其所有者</li>
<li>每个值同时只能有一个所有者</li>
<li>当所有者离开作用域时，值将被丢弃</li>
</ul>
<h2 id="变量作用域">变量作用域</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// s 从这里开始有效</span></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// s 作用域结束，s 无效</span></span><br></pre></td></tr></table></figure>
<h2 id="内存分配和释放">内存分配和释放</h2>
<h3 id="Stack（栈）数据">Stack（栈）数据</h3>
<ul>
<li>固定大小的数据</li>
<li>编译时大小已知</li>
<li>例如：整数、浮点数、布尔值、字符等</li>
</ul>
<h3 id="Heap（堆）数据">Heap（堆）数据</h3>
<ul>
<li>运行时大小可变的数据</li>
<li>编译时大小未知</li>
<li>例如：String、Vec、Box等</li>
</ul>
<h2 id="String类型详解">String类型详解</h2>
<h3 id="创建String">创建String</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 在堆上分配内存</span></span><br></pre></td></tr></table></figure>
<h3 id="移动（Move）">移动（Move）</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1; <span class="comment">// s1 被移动到 s2，s1 不再有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1); <span class="comment">// 编译错误：s1已被移动</span></span><br></pre></td></tr></table></figure>
<h3 id="克隆（Clone）">克隆（Clone）</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>(); <span class="comment">// 深度复制数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：s1和s2都有效</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br></pre></td></tr></table></figure>
<h2 id="所有权与函数">所有权与函数</h2>
<h3 id="传递值">传递值</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s); <span class="comment">// s的值被移动到函数中</span></span><br><span class="line">    <span class="comment">// s 在这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x); <span class="comment">// x是Copy类型，所以仍然可用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// some_string离开作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// some_integer离开作用域，无特殊操作</span></span><br></pre></td></tr></table></figure>
<h3 id="返回值与作用域">返回值与作用域</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>(); <span class="comment">// 获取返回值的所有权</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2); <span class="comment">// s2被移动到函数中</span></span><br><span class="line">&#125; <span class="comment">// s3离开作用域被丢弃，s2已被移动，s1离开作用域被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    a_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Copy-trait">Copy trait</h2>
<h3 id="实现Copy的类型">实现Copy的类型</h3>
<ul>
<li>所有整数类型</li>
<li>布尔类型</li>
<li>浮点类型</li>
<li>字符类型</li>
<li>元组（当且仅当其包含的类型也都实现了Copy）</li>
</ul>
<h3 id="示例">示例</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x; <span class="comment">// x被复制到y，x仍然有效</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h2 id="引用与借用">引用与借用</h2>
<h3 id="引用规则">引用规则</h3>
<ul>
<li>同一时间只能有一个可变引用</li>
<li>可以有多个不可变引用</li>
<li>可变引用和不可变引用不能同时存在</li>
</ul>
<h3 id="不可变引用">不可变引用</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27; 的长度是 &#123;&#125;&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可变引用">可变引用</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="悬垂引用（Dangling-References）">悬垂引用（Dangling References）</h2>
<p>Rust 编译器确保引用永远不会变成悬垂引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123; <span class="comment">// 编译错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &amp;s <span class="comment">// s离开作用域后被释放，返回其引用将导致悬垂引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切片（Slice）">切片（Slice）</h2>
<h3 id="字符串切片">字符串切片</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];  <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>]; <span class="comment">// &quot;world&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">whole</span> = &amp;s[..];    <span class="comment">// 整个字符串的切片</span></span><br></pre></td></tr></table></figure>
<h3 id="其他切片">其他切片</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>]; <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
</search>
