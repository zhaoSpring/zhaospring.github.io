<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>export和export default的差异</title>
    <url>/2025/01/20/export/</url>
    <content><![CDATA[<h1>总结</h1>
<h2 id="相同">相同</h2>
<ol>
<li>在ES6中，<code>export</code>和<code>export default</code>都可以导出变量、常量、函数、类、模块等；</li>
<li><code>export</code>和<code>export default</code>导出的内容都可以使用<code>import</code>来导入。</li>
</ol>
<h2 id="区别">区别</h2>
<ol>
<li>一个模块可以声明多个<code>export</code>，但只能声明一个<code>export default</code>；</li>
<li><code>export</code>暴露的是一个接口，可以导出多个值；<code>export default</code>暴露的是一个变量，只能导出一个值；</li>
<li>使用<code>export</code>导出时，<code>import</code>需要使用<code>&#123;&#125;</code>；使用<code>export default</code>导出时，<code>import</code>不需要使用<code>&#123;&#125;</code>。</li>
</ol>
<hr>
<h1>export</h1>
<p>要了解<code>export</code>和<code>export default</code>的区别，首先要了解<code>export</code>的基本概念。每个模块都是独立的文件。如果外部模块想要访问模块内部的变量或者或者函数，就必须使用<code>import</code>导入这些内容。<code>export</code>命名规定是<strong>对外的接口</strong>，必须与模块内部的变量一一对应。<br>
<code>export</code>有两种导出方式：</p>
<ol>
<li>具名导出</li>
<li>默认导出（即 <code>default export</code>）</li>
</ol>
<p><strong>一个模块中可以声明多个具名导出<code>export</code>，但是只能有一个默认导出<code>default export</code>。</strong></p>
<h2 id="具名导出">具名导出</h2>
<p><code>export</code>可以直接导出模块内声明的变量、常量、函数、类等，也可以导出模块内声明的其他模块。通常情况下，使用<code>export</code>导出的变量名可以直接使用，如果想要修改变量名可以使用<code>as</code>关键字进行修改</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法一：导出声明</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name1, name2<span class="comment">/*, … */</span>; <span class="comment">// also var</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name1 = <span class="number">1</span>, name2 = <span class="number">2</span><span class="comment">/*, … */</span>; <span class="comment">// also var, let</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params"></span>) &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span>* <span class="title function_">generatorFunctionName</span>(<span class="params"></span>) &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; name1, <span class="attr">name2</span>: bar &#125; = o;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> [ name1, name2 ] = array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二：导出列表</span></span><br><span class="line"><span class="keyword">export</span> &#123; name1, <span class="comment">/* …, */</span> nameN &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; variable1 <span class="keyword">as</span> name1, variable2 <span class="keyword">as</span> name2, <span class="comment">/* …, */</span> nameN &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; variable1 <span class="keyword">as</span> <span class="string">&quot;string name&quot;</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; name1 <span class="keyword">as</span> <span class="keyword">default</span> <span class="comment">/*, … */</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三：导出模块合集</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> name1 <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; name1, <span class="comment">/* …, */</span> nameN &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; import1 <span class="keyword">as</span> name1, import2 <span class="keyword">as</span> name2, <span class="comment">/* …, */</span> nameN &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span>, <span class="comment">/* …, */</span> &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> name1 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>模块外可以通过<code>import</code>导入<code>export</code>声明的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具名导入：</span></span><br><span class="line"><span class="keyword">import</span> &#123; export1 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1 <span class="keyword">as</span> alias1 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1, export2 &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; export1, export2 <span class="keyword">as</span> alias2, <span class="comment">/* … */</span> &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">&quot;string name&quot;</span> <span class="keyword">as</span> alias &#125; <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用<code>import</code>导入时，注意需要使用<code>&#123;&#125;</code>。因为<code>export</code>暴露的是一个接口，可以导出多个值</strong></p>
<hr>
<h1>export default</h1>
<p><code>export</code>还有一种写法，即<code>export default</code>，它用于声明模块的默认导出。一个模块只能有一个默认导出，所以<code>export defalut</code>只能使用一次。</p>
<h2 id="默认导出">默认导出</h2>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写法四：默认导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> expression;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">functionName</span>(<span class="params"></span>) &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">ClassName</span> &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>* <span class="title function_">generatorFunctionName</span>(<span class="params"></span>) &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> (<span class="params"></span>) &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> &#123; <span class="comment">/* … */</span> &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>* () &#123; <span class="comment">/* … */</span> &#125;</span><br></pre></td></tr></table></figure>
<p>模块外可以通过<code>import</code>导入<code>export</code>声明的内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 默认导入：</span></span><br><span class="line"><span class="keyword">import</span> defaultExport <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br></pre></td></tr></table></figure>
<p><strong>使用<code>import</code>时不需要加<code>&#123;&#125;</code>，因为<code>export default</code>暴露的是一个变量，只导出一个值。</strong></p>
<hr>
<blockquote>
<p>参考：<br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export</a><br>
<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import</a></p>
</blockquote>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>px、dp理解</title>
    <url>/2025/05/13/px%E3%80%81dp%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>最近使用<code>px</code>、<code>dp</code>有点感悟，记录一下~</p>
<h1>px</h1>
<p><code>px</code>是像素（<code>pixel</code>）的缩写，是屏幕像素的基本单位。</p>
<ul>
<li><code>1px</code>代表屏幕上的一个物理像素点。</li>
<li>在不同设备上，<code>1px</code>的实际显示大小是不一样的，这取决于设备的<strong>像素密度</strong>。</li>
</ul>
<p>如下图所示（图片来自<a href="http://developer.android.com/guide/practices/screens_support.html?spm=a2c6h.12873639.article-detail.5.66807717aqjkBd">android developer guide</a>），两款尺寸相同的手机，但是像素密度不同，导致显示的<code>1px</code>大小也不同。</p>
<p align = "center">    
<img  src="px-dp-1.png" width="400" />
</p>
<p><code>px</code>不建议直接使用，因为同为<code>100px</code>的图片，在不同手机上显示的实际大小可能不同，如下图所示：</p>
<p><img src="px-dp-2.png" alt=""></p>
<p>但也有一些特殊的场景需要用到<code>px</code>，例如：需要画1像素表格线或阴影线的时候，用其他单位如dp会显得模糊</p>
<h1>dpi/ppi</h1>
<p><code>dpi</code>和<code>ppi</code>都能表示<strong>像素密度</strong>，但它们的含义略有不同：</p>
<ul>
<li><code>dpi</code>：表示水平或垂直方向每英寸的像素数</li>
<li><code>ppi</code>：表示沿对角线方向每英寸长度的像素数</li>
</ul>
<h1>dp</h1>
<p><code>dp</code>是独立像素密度（<code>density-independent pixel</code>）的缩写，是 <code>Android</code> 中常用的一个单位，也叫 <code>dip</code>。</p>
<ul>
<li><code>dp</code> 是一个与设备屏幕密度无关的抽象单位。</li>
<li><code>dp</code>单位的目的是让 UI 在不同分辨率和密度的设备上具有一致的显示效果。</li>
<li>在 <code>160dpi</code>（即基准密度）的屏幕上，1 <code>dp</code> = 1 <code>px</code>。</li>
<li>不同密度的设备会自动根据比例将 <code>dp</code> 转换为对应的 <code>px</code>。</li>
</ul>
<p><strong>转化公式：</strong></p>
<p align = "center">    
<img  src="px-dp-3.png" width="200" />
</p>
<p>不同的手机/平板可能具有不同的像素密度，<code>Android</code>系统定义了四种像素密度：低（ <code>120dpi</code>）、中（<code>160dpi</code>）、高（<code>240dpi</code>）和超高（<code>320dpi</code>）。</p>
<p>例如，界面上有一个长度为<code>80dp</code>的图片，那么它在：</p>
<ul>
<li>低密度设备上（<code>120dpi</code>）显示为：<code>80dp * 120dpi / 160dpi = 60px</code></li>
<li>中密度设备上（<code>160dpi</code>）显示为：<code>80dp * 160dpi / 160dpi = 80px</code></li>
<li>高密度设备上（<code>240dpi</code>）显示为：<code>80dp * 240dpi / 160dpi = 120px</code></li>
<li>超高密度设备上（<code>320dpi</code>）显示为：<code>80dp * 320dpi / 160dpi = 160px</code></li>
</ul>
<p>如果你拿这几部手机放在一起对比，会发现这个图片的物理尺寸“差不多”，这就是使用<code>dp</code>作为单位的效果，如下图所示：</p>
<p><img src="px-dp-4.png" alt=""></p>
<p>当需要确保组件在不同设备（如桌面、平板、手机等）上看起来一致时推荐使用<code>dp</code>。</p>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>git rebase 与 merge区别</title>
    <url>/2025/06/25/rebase-merge/</url>
    <content><![CDATA[<h2 id="一图概览">一图概览</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>git merge</th>
<th>git rebase</th>
</tr>
</thead>
<tbody>
<tr>
<td>操作本质</td>
<td>创建一个新的合并提交</td>
<td>把你的提交“挪到”目标分支之后</td>
</tr>
<tr>
<td>提交历史</td>
<td>保留分支分叉（图像呈现树状）</td>
<td>线性历史（图像像一条直线）</td>
</tr>
<tr>
<td>是否修改提交历史</td>
<td>否</td>
<td>是（修改提交 ID）</td>
</tr>
<tr>
<td>是否需要强推</td>
<td>通常不需要</td>
<td>是（如果之前 push 过，rebase 后需 -f）</td>
</tr>
<tr>
<td>冲突处理方式</td>
<td>一次性解决合并冲突</td>
<td>每一个提交可能触发冲突，逐个解决</td>
</tr>
<tr>
<td>合并记录</td>
<td>有合并 commit（如 “Merge branch…”）</td>
<td>没有合并记录，提交像是直接在主干上产生的</td>
</tr>
</tbody>
</table>
<h2 id="示例对比">示例对比</h2>
<h3 id="1-git-merge-的效果">1. git merge 的效果</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git merge feature</span><br></pre></td></tr></table></figure>
<p>图示：<br>
原始：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A---B---C  (main)</span><br><span class="line">     \</span><br><span class="line">      D---E  (feature)</span><br></pre></td></tr></table></figure>
<p>merge 后：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A---B---C--------M  (main)</span><br><span class="line">     \        /</span><br><span class="line">      D------E</span><br></pre></td></tr></table></figure>
<p>多了一个 M 合并提交。</p>
<h3 id="2-git-rebase-的效果">2. git rebase 的效果</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout feature</span><br><span class="line">git rebase main</span><br></pre></td></tr></table></figure>
<p>图示：</p>
<p>原始：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A---B---C  (main)</span><br><span class="line">     \</span><br><span class="line">      D---E  (feature)</span><br></pre></td></tr></table></figure>
<p>rebase 后：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">A---B---C---D&#x27;---E&#x27;  (feature)</span><br></pre></td></tr></table></figure>
<p>D 和 E 被“摘下来”并重放到 C 之后。</p>
<h2 id="使用建议">使用建议</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐操作</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>个人开发，准备提交合并请求</td>
<td>rebase</td>
<td>保持提交记录整洁，便于评审</td>
</tr>
<tr>
<td>多人协作，主分支合并 feature 分支</td>
<td>merge</td>
<td>不改历史，不影响他人 pull 的内容</td>
</tr>
<tr>
<td>不关心历史美观，只想快速合并</td>
<td>merge</td>
<td>简单直接</td>
</tr>
<tr>
<td>想清晰回溯每个功能点的开发过程</td>
<td>merge</td>
<td>每个合并点都是功能点</td>
</tr>
<tr>
<td>想让历史看起来像一次性开发完成</td>
<td>rebase</td>
<td>可线性回顾整个演进过程</td>
</tr>
</tbody>
</table>
<h2 id="快速记忆">快速记忆</h2>
<p>merge 是把别人拉进来；rebase 是把自己放到别人后面。</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>密码算法RSA、AES的介绍与js实现</title>
    <url>/2025/01/16/rsa-aes/</url>
    <content><![CDATA[<h1>RSA算法</h1>
<p><img src="rsa-aes-1.png" alt=""></p>
<blockquote>
<p>参考：<br>
<a href="https://blog.csdn.net/a745233700/article/details/102341542">https://blog.csdn.net/a745233700/article/details/102341542</a><br>
<a href="https://blog.csdn.net/IT_luosong/article/details/128228961">https://blog.csdn.net/IT_luosong/article/details/128228961</a><br>
<a href="https://www.jianshu.com/p/b32fc387d8ad">https://www.jianshu.com/p/b32fc387d8ad</a></p>
</blockquote>
<h2 id="RSA加密">RSA加密</h2>
<p><img src="rsa-aes-2.png" alt=""><br>
RSA的加密过程可以使用一个通式来表达：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>密文</mtext><mo>=</mo><mtext>明</mtext><msup><mtext>文</mtext><mi>E</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">密文 = 明文^EmodN
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">密文</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord cjk_fallback">明</span><span class="mord"><span class="mord cjk_fallback">文</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05764em;">E</span></span></span></span></span></span></span></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p>
<p>E、N是RSA加密的密钥，也就是说E和N的组合就是公钥，我们用(E,N)来表示公钥：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>公钥</mtext><mo>=</mo><mtext>（</mtext><mi>E</mi><mtext>，</mtext><mi>N</mi><mtext>）</mtext></mrow><annotation encoding="application/x-tex">公钥 = （E，N）
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">公钥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">）</span></span></span></span></span></p>
<p>常用<strong>jsrsasign.js</strong>库实现数字签名过程：</p>
 <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 公钥（标准的pem格式，含开始标记，结束标记）</span></span><br><span class="line"><span class="keyword">let</span> pk=<span class="string">&quot;-----BEGIN PUBLIC KEY-----\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQD3XSdz1MnzazBEN5KOfTx0IyVJ\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;Z5wb57isrCuHDhnYXwtmdhQalgII0fozeeFpMpAvlnmHC1kpW7XVGvZnLx3bWbCE\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;bf+pMSW4kmQuI+5cxRUJbCl7sdaODBrINgERHPICVC18AJLThEVMHyjuR6Jn4zQm\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;yYNbReSktY/BrFTvMQIDAQAB\n&quot;</span> +</span><br><span class="line">    <span class="string">&quot;-----END PUBLIC KEY-----&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 原文</span></span><br><span class="line"><span class="keyword">var</span> src = <span class="string">&quot;好厉害&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="comment">// 读取解析pem格式的公钥, 生成秘钥实例 (RSAKey) </span></span><br><span class="line"><span class="keyword">var</span> pub = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">getKey</span>(pk);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用encrypt方法, 传入明文和公钥实例, 加密后的返回值是16进制字符串.</span></span><br><span class="line"><span class="keyword">var</span> enc = <span class="variable constant_">KJUR</span>.<span class="property">crypto</span>.<span class="property">Cipher</span>.<span class="title function_">encrypt</span>(src,pub);</span><br><span class="line"><span class="comment">// console.log(enc);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果为了方便放在URL上, 建议使用hextob64u(enc)将其转为Base64编码.（它会将+替换成-,/替换成_,去掉尾部补全的=）</span></span><br><span class="line"><span class="comment">// console.log(hextob64(enc));</span></span><br></pre></td></tr></table></figure>
<h2 id="RSA解密">RSA解密</h2>
<p><img src="rsa-aes-3.png" alt=""><br>
RSA的解密同样可以使用一个通式来表达：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>明文</mtext><mo>=</mo><mtext>密</mtext><msup><mtext>文</mtext><mi>D</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">明文 = 密文^DmodN
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">明文</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord cjk_fallback">密</span><span class="mord"><span class="mord cjk_fallback">文</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span></span></span></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p>
<p>D和N的组合就是私钥：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>私钥</mtext><mo>=</mo><mo stretchy="false">(</mo><mi>D</mi><mo separator="true">,</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">私钥 = (D,N)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">私钥</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 私钥</span></span><br><span class="line"> <span class="keyword">let</span> priK = <span class="string">&quot;-----BEGIN PRIVATE KEY-----\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;MIICeAIBADANBgkqhkiG9w0BAQEFAASCAmIwggJeAgEAAoGBAPddJ3PUyfNrMEQ3\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;ko59PHQjJUlnnBvnuKysK4cOGdhfC2Z2FBqWAgjR+jN54WkykC+WeYcLWSlbtdUa\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;9mcvHdtZsIRt/6kxJbiSZC4j7lzFFQlsKXux1o4MGsg2AREc8gJULXwAktOERUwf\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;KO5HomfjNCbJg1tF5KS1j8GsVO8xAgMBAAECgYEA6eG1JMrj63jEmStmMb1txG1a\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;mu4Q5z2QGgtr2HVXsIIlGEq6tWxyHf7TL4qkuz9onuYKn8n2Eqm44fZtVaBx+5ES\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;zRpIvlTvaxmVu0HZ1hYAzUw1XyRnXNMKpL5tT4GCjm8+QGPzlGxgXI1sNg8r9Jaw\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;9zRUYeA6LQR9RIMkHWUCQQD8QojjVoGjtiunoh/N8iplhUszZIavAEvmDIE+kVy+\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;pA7hvlukLw6JMc7cfTcnHyxDo9iHVIzrWlTuKRq9KWVLAkEA+wgJS2sgtldnCVn6\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;tJKFVwsHrWhMIU29msPPbNuWUD23BcKE/vehIyFu1ahNA/TiM40PEnzprQ5JfPxU\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;16S78wJANTfMLTnYy7Lo7sqTLx2BuD0wqjzw9QZ4/KVytsJv8IAn65P/PVn4FRV+\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;8KEx+3zmF7b/PT2nJRe/hycAzxtmlQJBAMrFwQxEqpXfoAEzx4lY2ZBn/nmaR/SW\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;4VNEXCbocVC7qT1j1R5HVMgV13uKiTtq8dUGWmhqsi7x3XayNK5ECPUCQQDZaAN6\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;tvIHApz9OLsXSw0jZirQ6KEYdharXbIVDy1W1sVE3lzLbqLdFp1bxAHQIvsYS5PM\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;A9veSJh372RLJKkj\n&quot;</span> +</span><br><span class="line">     <span class="string">&quot;-----END PRIVATE KEY-----&quot;</span>;   </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="comment">// 读取解析pem格式的私钥, 生成秘钥实例 (RSAKey) </span></span><br><span class="line"> <span class="keyword">var</span> prv = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">getKey</span>(priK);</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 调用encrypt方法, 传入密文和私钥实例进行解密</span></span><br><span class="line"> <span class="keyword">var</span> dec = <span class="variable constant_">KJUR</span>.<span class="property">crypto</span>.<span class="property">Cipher</span>.<span class="title function_">decrypt</span>(enc,prv);</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;jsrsasign decrypt: &quot;</span>+dec);</span><br></pre></td></tr></table></figure>
<h2 id="RSA签名">RSA签名</h2>
<p><img src="rsa-aes-4.png" alt=""><br>
RSA生成签名的过程可用下列公式来表述：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>签名</mtext><mo>=</mo><mtext>（</mtext><mi>H</mi><mi>a</mi><mi>s</mi><mi>h</mi><mtext>（明文）</mtext><msup><mtext>）</mtext><mi>D</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>N</mi></mrow><annotation encoding="application/x-tex">签名 = （Hash（明文））^D mod N
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">签名</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8913em;"></span><span class="mord cjk_fallback">（</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal">a</span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord cjk_fallback">（明文）</span><span class="mord"><span class="mord cjk_fallback">）</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">D</span></span></span></span></span></span></span></span><span class="mord mathnormal">m</span><span class="mord mathnormal">o</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span></span></p>
<blockquote>
<p>Hash函数（摘要算法）：<a href="https://cloud.tencent.com/developer/article/1584742">https://cloud.tencent.com/developer/article/1584742</a></p>
</blockquote>
<p align = "center">    
<img  src="rsa-aes-5.png" width="600" />
</p>
常用**jsrsasign.js库**实现数字签名过程：
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 签名步骤: 先建立 key 对象, 构建 signature 实例, 传入 key 初始化 -&gt; 签名</span></span><br><span class="line"><span class="keyword">var</span> key = <span class="variable constant_">KEYUTIL</span>.<span class="title function_">getKey</span>(priK);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(key);</span><br><span class="line"><span class="comment">// 创建 Signature 对象，指定Hash算法</span></span><br><span class="line"><span class="keyword">let</span> signature=<span class="keyword">new</span> <span class="variable constant_">KJUR</span>.<span class="property">crypto</span>.<span class="title class_">Signature</span>(&#123;<span class="attr">alg</span>:<span class="string">&quot;SHA1withRSA&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// 传入key实例, 初始化signature实例</span></span><br><span class="line">signature.<span class="title function_">init</span>(key);</span><br><span class="line"><span class="comment">// 传入待签明文</span></span><br><span class="line">signature.<span class="title function_">updateString</span>(src);</span><br><span class="line"><span class="comment">// 签名, 得到16进制字符结果</span></span><br><span class="line"><span class="keyword">let</span> a = signature.<span class="title function_">sign</span>();</span><br><span class="line"><span class="comment">// 如果为了方便放在URL上, 将其转为常用的Base64编码.</span></span><br><span class="line"><span class="keyword">let</span> sign = <span class="title function_">hextob64</span>(a);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sign);</span><br></pre></td></tr></table></figure>
## RSA验签
![](rsa-aes-6.png)
RSA的签名验证过程可用下列公式来表述：
$$摘要 = 签名 ^E mod N$$
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 验签</span></span><br><span class="line"><span class="comment">// !要重新new 一个Signature, 否则, 取摘要和签名时取得摘要不一样, 导致验签误报失败(原因不明)!</span></span><br><span class="line"><span class="keyword">let</span> signatureVf = <span class="keyword">new</span> <span class="variable constant_">KJUR</span>.<span class="property">crypto</span>.<span class="title class_">Signature</span>(&#123;<span class="attr">alg</span>:<span class="string">&quot;SHA1withRSA&quot;</span>,<span class="attr">prvkeypem</span>:pk&#125;);</span><br><span class="line">signatureVf.<span class="title function_">updateString</span>(src);</span><br><span class="line"><span class="comment">// !接受的参数是16进制字符串!</span></span><br><span class="line"><span class="keyword">let</span> b = signatureVf.<span class="title function_">verify</span>(<span class="title function_">b64tohex</span>(sign));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;jsrsasign verify: &quot;</span>+b);</span><br></pre></td></tr></table></figure>
<h1>AES算法</h1>
<p><img src="rsa-aes-7.png" alt=""></p>
<blockquote>
<p>参考：<br>
密码学——AES/DES加密算法原理介绍 - 枫のBlog<br>
<a href="https://www.cnblogs.com/starwolf/p/3365834.html">https://www.cnblogs.com/starwolf/p/3365834.html</a></p>
</blockquote>
<h2 id="加密标准-模式">加密标准 &amp; 模式</h2>
<p>在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位，如果数据块及密钥长度不足时会补齐。密钥的长度不同，推荐加密轮数也不同，如下表所示：</p>
<table>
<thead>
<tr>
<th>AES</th>
<th>密钥长度（32位比特字）</th>
<th>分组长度(32位比特字)</th>
<th>加密轮数</th>
</tr>
</thead>
<tbody>
<tr>
<td>AES-128</td>
<td>4</td>
<td>4</td>
<td>10</td>
</tr>
<tr>
<td>AES-192</td>
<td>6</td>
<td>4</td>
<td>12</td>
</tr>
<tr>
<td>AES-256</td>
<td>8</td>
<td>4</td>
<td>14</td>
</tr>
</tbody>
</table>
<p>AES加密模式：</p>
<table>
<thead>
<tr>
<th>AES加密模式</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>电码本模式（Electronic Codebook Book (ECB)）</td>
<td>将整个明文分成若干段相同的小段，然后对每一小段进行加密。</td>
</tr>
<tr>
<td>密码分组链接模式（Cipher Block Chaining (CBC)）</td>
<td>先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。</td>
</tr>
<tr>
<td>计算器模式（Counter (CTR)）</td>
<td>计算器模式不常见，在CTR模式中，有一个自增的算子，这个算子用密钥加密之后的输出和明文异或的结果得到密文，相当于一次一密。这种加密方式简单快速，安全可靠，而且可以并行加密，但是在计算器不能维持很长的情况下，密钥只能使用一次。</td>
</tr>
<tr>
<td>密码反馈模式（Cipher FeedBack (CFB)）</td>
<td>这种模式较复杂</td>
</tr>
<tr>
<td>输出反馈模式（Output FeedBack (OFB)）</td>
<td>这种模式较复杂</td>
</tr>
</tbody>
</table>
<h2 id="加解密流程">加解密流程</h2>
<p>AES加解密主要有以下几步操作，完整的加解密流程是通过循环以下步骤来完成的，具体如下图表示</p>
<ul>
<li>轮密钥加</li>
<li>字节代换</li>
<li>行位移</li>
<li>列混合</li>
</ul>
<blockquote>
<p>具体步骤分析参考：<a href="https://goodapple.top/archives/162">https://goodapple.top/archives/162</a></p>
</blockquote>
<p><img src="rsa-aes-8.png" alt=""></p>
<h2 id="AES加密">AES加密</h2>
<p><img src="rsa-aes-9.png" alt=""><br>
设AES加密函数为E，则 C = E(K, P),其中P为明文，K为密钥，C为密文。也就是说，把明文P和密钥K作为加密函数的参数输入，则加密函数E会输出密文C</p>
<h2 id="AES解密">AES解密</h2>
<p><img src="rsa-aes-10.png" alt=""><br>
设AES解密函数为D，则 P = D(K, C),其中C为密文，K为密钥，P为明文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P<br>
常用<strong>crypto-js库</strong>实现AES加解密过程：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">CryptoJS</span> <span class="keyword">from</span> <span class="string">&#x27;crypto-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> key = <span class="string">&#x27;aaaabbbbccccdddd&#x27;</span><span class="comment">//秘钥</span></span><br><span class="line"><span class="keyword">const</span> iv = <span class="string">&#x27;1234567887654321&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Encrypt</span> (<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">encrypt</span>(text, <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(key), &#123;</span><br><span class="line">    <span class="attr">iv</span>: <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(iv),<span class="comment">//初始变量</span></span><br><span class="line">    <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span>,<span class="comment">//加密模式</span></span><br><span class="line">    <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span><span class="comment">//填充方式</span></span><br><span class="line">  &#125;).<span class="title function_">toString</span>()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解密</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Decrypt</span> (<span class="params">text</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> decrypted = <span class="title class_">CryptoJS</span>.<span class="property">AES</span>.<span class="title function_">decrypt</span>(text, <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(key), &#123;</span><br><span class="line">    <span class="attr">iv</span>: <span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>.<span class="title function_">parse</span>(iv),</span><br><span class="line">    <span class="attr">mode</span>: <span class="title class_">CryptoJS</span>.<span class="property">mode</span>.<span class="property">CBC</span>,</span><br><span class="line">    <span class="attr">padding</span>: <span class="title class_">CryptoJS</span>.<span class="property">pad</span>.<span class="property">Pkcs7</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> decrypted.<span class="title function_">toString</span>(<span class="title class_">CryptoJS</span>.<span class="property">enc</span>.<span class="property">Utf8</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="title class_">Encrypt</span>,</span><br><span class="line">  <span class="title class_">Decrypt</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="keyword">let</span> text = <span class="variable constant_">AES</span>.<span class="title class_">Encrypt</span>(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(text)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable constant_">AES</span>.<span class="title class_">Decrypt</span>(text))</span><br></pre></td></tr></table></figure>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>rust学习笔记1-变量与数据类型</title>
    <url>/2025/02/10/rust-1/</url>
    <content><![CDATA[<p><img src="rust1-1.png" alt=""></p>
<h2 id="变量">变量</h2>
<ol>
<li>使用 <code>let</code> 关键字声明变量</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">// 不可变变量</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">y</span> = <span class="number">10</span>; <span class="comment">// 可变变量</span></span><br><span class="line">    y = <span class="number">11</span>; <span class="comment">// 修改可变变量</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;&quot;</span>, x); <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;y: &#123;&#125;&quot;</span>, y); <span class="comment">// 11</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>变量默认<strong>不可变</strong>（immutable），需要修改时必须使用 <code>mut</code> 关键字</li>
<li>变量遮蔽（Shadow）：可以使用相同名称声明新变量，即第一个变量被第二个变量遮蔽（Shadow）</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = x + <span class="number">1</span>; <span class="comment">// 创建新变量，而不是修改原变量</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;x: &#123;&#125;&quot;</span>, x); <span class="comment">// 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="常量">常量</h2>
<ul>
<li>使用 <code>const</code> 关键字声明</li>
<li>必须注明类型</li>
<li>只能是<strong>常量表达式</strong>，不能是函数调用的结果或者运行时计算得到的值</li>
<li>常量命名规则：字母全部大写，使用下划线分隔单词</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MAX_POINTS: <span class="type">u32</span> = <span class="number">100000</span>;</span><br><span class="line"><span class="keyword">const</span> PI: <span class="type">f64</span> = <span class="number">3.14159</span>;</span><br><span class="line"><span class="keyword">const</span> HELLO_WORLD: &amp;<span class="type">str</span> = <span class="string">&quot;Hello, world!&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> A: <span class="type">char</span> = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> THREE_HOURS_IN_SECONDS: <span class="type">u32</span> = <span class="number">60</span> * <span class="number">60</span> * <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h2 id="数据类型">数据类型</h2>
<h3 id="标量类型">标量类型</h3>
<p>标量（scalar）表示单个值，有以下几种：</p>
<ol>
<li>整数类型</li>
</ol>
<ul>
<li>没有小数部分的数字</li>
<li>有符号：<code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code></li>
<li>无符号：<code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code></li>
<li>默认类型：<code>i32</code></li>
</ul>
<ol start="2">
<li>浮点数类型</li>
</ol>
<ul>
<li>带小数点的数字</li>
<li><code>f32</code>：单精度</li>
<li><code>f64</code>：双精度（默认类型）</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">2.0</span>; <span class="comment">// f64</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span>: <span class="type">f32</span> = <span class="number">3.0</span>; <span class="comment">// f32</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>布尔类型</li>
</ol>
<ul>
<li><code>bool</code>：true 或 false</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">t</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>: <span class="type">bool</span> = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>字符类型</li>
</ol>
<ul>
<li><code>char</code>：使用单引号，4个字节，表示 Unicode 字符</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = <span class="string">&#x27;z&#x27;</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">emoji</span> = <span class="string">&#x27;😻&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="复合类型">复合类型</h3>
<p>复合类型（compound type）可以将多个值组合成一个类型，有以下几种：</p>
<ol>
<li>元组类型</li>
</ol>
<ul>
<li>固定长度，用<code>()</code>表示</li>
<li>可以包含不同类型的值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">tup</span>: (<span class="type">i32</span>, <span class="type">f64</span>, <span class="type">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> (x, y, z) = tup; <span class="comment">// 解构</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first</span> = tup.<span class="number">0</span>; <span class="comment">// 使用索引访问</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>数组类型</li>
</ol>
<ul>
<li>固定长度，用<code>[]</code>表示</li>
<li>元素类型必须相同</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span>: [<span class="type">i32</span>; <span class="number">5</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">3</span>; <span class="number">5</span>]; <span class="comment">// [3, 3, 3, 3, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="类型转换">类型转换</h2>
<ol>
<li>使用 <code>as</code> 关键字进行基本类型转换</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123; </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">a</span> = <span class="number">3.14</span> <span class="keyword">as</span> <span class="type">i32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;a: &#123;&#125;&quot;</span>, a); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>数字之间的类型转换要注意可能的精度损失和溢出</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="number">256_i32</span> <span class="keyword">as</span> <span class="type">i8</span>; <span class="comment">// 可能溢出</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;b: &#123;&#125;&quot;</span>, b); <span class="comment">// 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注意事项">注意事项</h2>
<ol>
<li>Rust 是静态类型语言，编译时必须知道所有变量的类型</li>
<li>大多数情况下编译器可以推断类型</li>
<li>当可能存在多种类型时，必须添加类型注解</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">guess</span>: <span class="type">u32</span> = <span class="string">&quot;42&quot;</span>.<span class="title function_ invoke__">parse</span>().<span class="title function_ invoke__">expect</span>(<span class="string">&quot;不是数字！&quot;</span>);</span><br></pre></td></tr></table></figure>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust学习笔记2-函数</title>
    <url>/2025/02/10/rust-2/</url>
    <content><![CDATA[<p><img src="rust2-1.png" alt=""></p>
<h2 id="函数定义">函数定义</h2>
<ul>
<li>fn关键字声明函数</li>
<li>函数名使用下划线命名法（蛇形命名法，snake_case）：字母小写，下划线分隔单词</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> &lt;函数名&gt;(&lt;参数: 类型&gt;) &lt;函数体&gt;</span><br></pre></td></tr></table></figure>
<p>示例：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(x: <span class="type">i32</span>, y: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    x + y  <span class="comment">// 无分号，作为返回值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">greet</span>(name: &amp;<span class="type">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;你好, &#123;&#125;!&quot;</span>, name);  <span class="comment">// 无返回值，等同于返回 ()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数参数">函数参数</h2>
<ul>
<li>必须声明每个参数的类型</li>
<li>参数数量是固定的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">print_sum</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;和是: &#123;&#125;&quot;</span>, a + b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数体的语句和表达式">函数体的语句和表达式</h2>
<ul>
<li>语句：执行操作但不返回值，<strong>语句末尾有<code>;</code></strong></li>
<li>表达式：计算并返回值，<strong>表达式末尾没有<code>;</code></strong></li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">expression_example</span>() <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">3</span>; <span class="comment">// 语句</span></span><br><span class="line">        x + <span class="number">1</span>  <span class="comment">// 表达式，返回 4</span></span><br><span class="line">    &#125;;</span><br><span class="line">    y + <span class="number">2</span> <span class="comment">// 表达式，返回 6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="函数返回值">函数返回值</h2>
<ul>
<li>使用 -&gt; 声明返回类型</li>
<li>隐式返回最后一个表达式的值</li>
<li>也可以使用 return 提前返回指定值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">get_square</span>(num: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    num * num  <span class="comment">// 隐式返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">check_number</span>(num: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> num &lt; <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 提前返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="literal">true</span>  <span class="comment">// 隐式返回</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust学习笔记3-注释</title>
    <url>/2025/02/11/rust-3/</url>
    <content><![CDATA[<h2 id="普通注释">普通注释</h2>
<h3 id="行注释">行注释</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是一个行注释</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>; <span class="comment">// 这是一个行尾注释</span></span><br></pre></td></tr></table></figure>
<h3 id="块注释">块注释</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 这是一个块注释</span></span><br><span class="line"><span class="comment">   可以跨越多行 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 块注释可以</span></span><br><span class="line"><span class="comment">   <span class="comment">/* 嵌套使用 */</span></span></span><br><span class="line"><span class="comment">   非常方便 */</span></span><br></pre></td></tr></table></figure>
<h2 id="文档注释">文档注释</h2>
<h3 id="外部文档注释（-）">外部文档注释（///）</h3>
<p>用于函数、结构体、方法等项的文档：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 计算两个数字的和</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # 参数</span></span><br><span class="line"><span class="comment">/// * `a` - 第一个数字</span></span><br><span class="line"><span class="comment">/// * `b` - 第二个数字</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # 示例</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// let result = add(1, 2);</span></span><br><span class="line"><span class="comment">/// assert_eq!(result, 3);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">add</span>(a: <span class="type">i32</span>, b: <span class="type">i32</span>) <span class="punctuation">-&gt;</span> <span class="type">i32</span> &#123;</span><br><span class="line">    a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 表示一个矩形的结构体</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">Rectangle</span> &#123;</span><br><span class="line">    width: <span class="type">u32</span>,</span><br><span class="line">    height: <span class="type">u32</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="内部文档注释（-）">内部文档注释（//!）</h3>
<p>用于模块或包的整体文档：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//! # 数学计算模块</span></span><br><span class="line"><span class="comment">//! </span></span><br><span class="line"><span class="comment">//! 这个模块提供了基本的数学计算功能。</span></span><br><span class="line"><span class="comment">//! </span></span><br><span class="line"><span class="comment">//! ## 主要功能：</span></span><br><span class="line"><span class="comment">//! - 基础运算</span></span><br><span class="line"><span class="comment">//! - 几何计算</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mod</span> math &#123;</span><br><span class="line">    <span class="comment">// 模块内容</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文档注释格式">文档注释格式</h2>
<h3 id="常用章节标记">常用章节标记</h3>
<ul>
<li><code># Examples</code> - 示例代码</li>
<li><code># Panics</code> - 可能的 panic 情况</li>
<li><code># Errors</code> - 错误处理说明</li>
<li><code># Safety</code> - 安全性说明</li>
<li><code># Arguments</code> - 参数说明</li>
<li><code># Returns</code> - 返回值说明</li>
</ul>
<h3 id="示例">示例</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 将字符串转换为大写</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # Arguments</span></span><br><span class="line"><span class="comment">/// * `text` - 要转换的字符串</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # Returns</span></span><br><span class="line"><span class="comment">/// 转换后的大写字符串</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # Examples</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// let upper = to_uppercase(&quot;hello&quot;);</span></span><br><span class="line"><span class="comment">/// assert_eq!(upper, &quot;HELLO&quot;);</span></span><br><span class="line"><span class="comment">/// ```</span></span><br><span class="line"><span class="comment">/// </span></span><br><span class="line"><span class="comment">/// # Errors</span></span><br><span class="line"><span class="comment">/// 如果输入不是有效的 UTF-8 字符串，将返回错误</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">fn</span> <span class="title function_">to_uppercase</span>(text: &amp;<span class="type">str</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    text.<span class="title function_ invoke__">to_uppercase</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust学习笔记5-所有权</title>
    <url>/2025/02/12/rust-5/</url>
    <content><![CDATA[<h2 id="所有权规则">所有权规则</h2>
<ul>
<li>每个值都有一个变量，称为其所有者</li>
<li>每个值同时只能有一个所有者</li>
<li>当所有者离开作用域时，值将被丢弃</li>
</ul>
<h2 id="变量作用域">变量作用域</h2>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">&#123;                      <span class="comment">// s 在这里无效</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="string">&quot;hello&quot;</span>;   <span class="comment">// s 从这里开始有效</span></span><br><span class="line">    <span class="comment">// 使用 s</span></span><br><span class="line">&#125;                      <span class="comment">// s 作用域结束，s 无效</span></span><br></pre></td></tr></table></figure>
<h2 id="内存分配和释放">内存分配和释放</h2>
<h3 id="Stack（栈）数据">Stack（栈）数据</h3>
<ul>
<li>固定大小的数据</li>
<li>编译时大小已知</li>
<li>例如：整数、浮点数、布尔值、字符等</li>
</ul>
<h3 id="Heap（堆）数据">Heap（堆）数据</h3>
<ul>
<li>运行时大小可变的数据</li>
<li>编译时大小未知</li>
<li>例如：String、Vec、Box等</li>
</ul>
<h2 id="String类型详解">String类型详解</h2>
<h3 id="创建String">创建String</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// 在堆上分配内存</span></span><br></pre></td></tr></table></figure>
<h3 id="移动（Move）">移动（Move）</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1; <span class="comment">// s1 被移动到 s2，s1 不再有效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误示例</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, s1); <span class="comment">// 编译错误：s1已被移动</span></span><br></pre></td></tr></table></figure>
<h3 id="克隆（Clone）">克隆（Clone）</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>(); <span class="comment">// 深度复制数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确：s1和s2都有效</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;&#125;, s2 = &#123;&#125;&quot;</span>, s1, s2);</span><br></pre></td></tr></table></figure>
<h2 id="所有权与函数">所有权与函数</h2>
<h3 id="传递值">传递值</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">takes_ownership</span>(s); <span class="comment">// s的值被移动到函数中</span></span><br><span class="line">    <span class="comment">// s 在这里不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line">    <span class="title function_ invoke__">makes_copy</span>(x); <span class="comment">// x是Copy类型，所以仍然可用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); <span class="comment">// 正确</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_ownership</span>(some_string: <span class="type">String</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// some_string离开作用域并被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">makes_copy</span>(some_integer: <span class="type">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// some_integer离开作用域，无特殊操作</span></span><br></pre></td></tr></table></figure>
<h3 id="返回值与作用域">返回值与作用域</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="title function_ invoke__">gives_ownership</span>(); <span class="comment">// 获取返回值的所有权</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s3</span> = <span class="title function_ invoke__">takes_and_gives_back</span>(s2); <span class="comment">// s2被移动到函数中</span></span><br><span class="line">&#125; <span class="comment">// s3离开作用域被丢弃，s2已被移动，s1离开作用域被丢弃</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">gives_ownership</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">takes_and_gives_back</span>(a_string: <span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    a_string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Copy-trait">Copy trait</h2>
<h3 id="实现Copy的类型">实现Copy的类型</h3>
<ul>
<li>所有整数类型</li>
<li>布尔类型</li>
<li>浮点类型</li>
<li>字符类型</li>
<li>元组（当且仅当其包含的类型也都实现了Copy）</li>
</ul>
<h3 id="示例">示例</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x; <span class="comment">// x被复制到y，x仍然有效</span></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;x = &#123;&#125;, y = &#123;&#125;&quot;</span>, x, y); <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h2 id="引用与借用">引用与借用</h2>
<h3 id="引用规则">引用规则</h3>
<ul>
<li>同一时间只能有一个可变引用</li>
<li>可以有多个不可变引用</li>
<li>可变引用和不可变引用不能同时存在</li>
</ul>
<h3 id="不可变引用">不可变引用</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#x27;&#123;&#125;&#x27; 的长度是 &#123;&#125;&quot;</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123;</span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可变引用">可变引用</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="悬垂引用（Dangling-References）">悬垂引用（Dangling References）</h2>
<p>Rust 编译器确保引用永远不会变成悬垂引用：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123; <span class="comment">// 编译错误</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &amp;s <span class="comment">// s离开作用域后被释放，返回其引用将导致悬垂引用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="切片（Slice）">切片（Slice）</h2>
<h3 id="字符串切片">字符串切片</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>];  <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>]; <span class="comment">// &quot;world&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">whole</span> = &amp;s[..];    <span class="comment">// 整个字符串的切片</span></span><br></pre></td></tr></table></figure>
<h3 id="其他切片">其他切片</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>]; <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>rust学习笔记4-控制流</title>
    <url>/2025/02/11/rust-4/</url>
    <content><![CDATA[<h2 id="if-表达式">if 表达式</h2>
<h3 id="if">if</h3>
<ul>
<li>条件必须是bool值，否则会报错</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> number &lt; <span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;条件为真&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;条件为假&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="else-if">else if</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> number % <span class="number">4</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;数字能被4整除&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> number % <span class="number">3</span> == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;数字能被3整除&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;数字不能被4或3整除&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="在-let-语句中使用if">在 let 语句中使用if</h3>
<ul>
<li>if else每个分支返回值类型必须一致</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">condition</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">number</span> = <span class="keyword">if</span> condition &#123; <span class="number">5</span> &#125; <span class="keyword">else</span> &#123; <span class="number">6</span> &#125;; <span class="comment">// 返回值类型相同：i32</span></span><br></pre></td></tr></table></figure>
<h2 id="循环">循环</h2>
<h3 id="loop-循环">loop 循环</h3>
<ul>
<li>使用break停止循环</li>
<li>使用break表达式添加返回值</li>
</ul>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line"><span class="keyword">loop</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;永远循环！&quot;</span>);</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 使用break退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从循环返回值</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">counter</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">result</span> = <span class="keyword">loop</span> &#123;</span><br><span class="line">    counter += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;结果是: &#123;&#125;&quot;</span>, result); <span class="comment">// 结果是: 20</span></span><br></pre></td></tr></table></figure>
<h3 id="while-循环">while 循环</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">number</span> = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;!&quot;</span>, number); <span class="comment">// 3! 2! 1!</span></span><br><span class="line">    number -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="for-循环">for 循环</h3>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遍历范围</span></span><br><span class="line"><span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">1</span>..=<span class="number">5</span> &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;值是: &#123;&#125;&quot;</span>, i); <span class="comment">// 值是: 1 值是: 2 值是: 3 值是: 4 值是: 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历集合</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="variable">element</span> <span class="keyword">in</span> arr.<span class="title function_ invoke__">iter</span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;值是: &#123;&#125;&quot;</span>, element); <span class="comment">// 值是: 10 值是: 20 值是: 30 值是: 40 值是: 50</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>rust</category>
      </categories>
      <tags>
        <tag>rust</tag>
      </tags>
  </entry>
  <entry>
    <title>从0开始编写mcp client</title>
    <url>/2025/06/10/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E7%BC%96%E5%86%99mcpClient/</url>
    <content><![CDATA[<h1>MCP-Client介绍</h1>
<h2 id="什么是MCP-Client">什么是MCP-Client</h2>
<p>MCP-Client 是 Model Context Protocol（模型上下文协议）架构中的关键一环，主要作用是作为大型语言模型（如 GPT、Claude 等）与外部系统之间的连接器，使模型能够访问实时数据和第三方工具。MCP 的核心是<strong>客户端-服务器架构</strong>，其中主机应用程序可以连接到多个服务器：<br>
<img src="mcp-1.png" alt=""><br>
Model Context Protocol（MCP）由 Anthropic 于 2024 年底提出并开源，作为一种开放协议，旨在解决当前大模型在获取外部信息方面的局限性。通过引入 MCP，模型不再局限于训练数据本身，而是可以标准化地接入外部资源，从而拓宽了其实际应用的广度与深度。<br>
整个 MCP 架构由三个主要组成部分构成：</p>
<ul>
<li><strong>MCP 服务器（Server）</strong>：这是与外部系统对接的服务模块，负责封装具体的功能或数据来源，例如 API 接口、数据库或文件系统。服务器端遵循 MCP 标准，为客户端提供统一的调用接口。</li>
<li><strong>MCP 客户端（Client）</strong>：内嵌于 AI 应用中，用于与 MCP 服务器建立单点连接。它负责服务发现、请求发送、结果接收，并将返回信息整理后提供给语言模型，起到了中介与协调的作用。</li>
<li><strong>宿主应用（Host）</strong>：指运行语言模型的具体平台，如 Claude 的桌面版本或集成开发环境 Cursor IDE。宿主通过接入 MCP-Client，使模型具备调用外部工具的能力。<br>
MCP-Client 基于<a href="https://wiki.geekdream.com/Specification/json-rpc_2.0.html"><code>JSON-RPC 2.0</code></a> 协议与 MCP 服务器通信，通过标准接口交互数据。它能够自动识别并注册可用的服务，解析其功能，并以结构化方式呈现给大模型，从而使模型能够理解和调用这些功能，以满足用户需求。</li>
</ul>
<blockquote>
<p>想了解更详细的MCP知识推荐查阅官网：<a href="https://modelcontextprotocol.io/introduction">https://modelcontextprotocol.io/introduction</a></p>
</blockquote>
<h2 id="现有的MCP-Client">现有的MCP-Client</h2>
<ul>
<li>MCP 客户端是 AI 的“操作台”，以下是几个热门选择：
<ul>
<li>Claude Desktop
<ul>
<li>简介：Claude 桌面版，普通人也能用。</li>
<li>功能：官方客户端，连接各种MCP服务器，例如连 Blender MCP，用自然语言建 3D 模型。</li>
<li>链接：<a href="https://docs.anthropic.com/">Anthropic 官网</a></li>
<li>截图：<br>
<img src="mcp-2.png" alt=""></li>
<li>Tips：不写代码也能玩，新手友好。</li>
</ul>
</li>
<li>Cherry Studio
<ul>
<li>简介：新兴客户端，支持可视化配置。</li>
<li>功能：点选即可配置MCP服务器，简单上手。</li>
<li>链接：<a href="https://github.com/CherryHQ/cherry-studio">Cherry Studio</a></li>
<li>截图：<br>
<img src="mcp-3.png" alt=""></li>
<li>Tips：开发中，关注社区动态。</li>
</ul>
</li>
</ul>
</li>
<li>Cursor【推荐】
<ul>
<li>简介：代码编辑器，装上 MCP 变“全能选手”。</li>
<li>功能：写代码、发 Slack、生成图片。</li>
<li>链接：<a href="https://cursor.sh/">Cursor</a></li>
<li>截图：<br>
<img src="mcp-4.png" alt=""></li>
<li>Tips：程序员必备，试试连 GitHub MCP。</li>
</ul>
</li>
</ul>
<blockquote>
<p>想了解更多的MCP Client知识可以查看这里：<a href="https://github.com/yzfly/Awesome-MCP-ZH">https://github.com/yzfly/Awesome-MCP-ZH</a></p>
</blockquote>
<h2 id="为什么要自己写MCP-Client？">为什么要自己写MCP-Client？</h2>
<p><strong>1. 更好地整合本地系统或服务</strong><br>
你可能有一些本地服务、脚本、数据库或工具，而官方或通用的 MCP 客户端并不支持直接调用它们。自己写客户端可以将它们包装成 MCP 工具，便于你在 ChatGPT 或其他智能代理中调用。</p>
<blockquote>
<p>例子：你公司内部有一个部署在内网的报表生成器，通过写一个 MCP Client，你可以直接在 ChatGPT 中用自然语言触发生成报表。</p>
</blockquote>
<p><strong>2. 自定义权限控制与安全策略</strong><br>
写 MCP Client 时你可以完全控制用户身份校验、访问权限、数据加密、调用频率限制等，这在处理敏感数据或生产系统时非常重要。<br>
<strong>3. 实现专属业务逻辑或自动化流程</strong><br>
官方客户端只提供通用能力，而你的业务流程可能需要多步任务、状态管理、数据中转等。通过自定义 Client，可以实现自己的：</p>
<ul>
<li>多工具组合执行逻辑</li>
<li>异步处理机制</li>
<li>工作流状态管理</li>
</ul>
<p><strong>4. 支持私有部署</strong><br>
如果你的环境需要离线运行（如内网、无法联网的服务器），自建 MCP Client 是唯一方式，可以脱离 OpenAI 的托管基础设施，自行实现完整工具协议栈。<br>
<strong>5. 调试 &amp; 可观测性更好</strong><br>
你可以添加日志、性能监控、调试输出等开发者工具，让你的工具行为更透明，便于开发、排查问题和运维。<br>
<strong>6. 适配特殊协议或格式</strong><br>
MCP 协议是开放的，我们可以根据特定业务所需的非标准通信或数据格式要求，自己需要添加字段、支持新指令、扩展输入结构，而不需要等待官方支持。</p>
<h1>MCP调用流程</h1>
<p><img src="mcp-5.png" alt=""></p>
<ol>
<li>MCP Client会向LLM发送用户问题，同时在tools附上MCP Server提供的所有function以及说明</li>
<li>LLM根据用户问题自行判断需要tools中的function，返回需要调用的function以及对应的参数</li>
<li>MCP Client根据指示完成function的调用，并将调用结果和用户原始问题发送给LLM</li>
<li>LLM根据用户问题以及function的结果整理最终答案返回给MCP Client</li>
</ol>
<p>一次MCP完整的调用流程如下：<br>
<img src="mcp-6.png" alt=""><br>
图中省略了第一步与第二步之间，<code>list_tools()</code>或<code>resource()</code>的步骤，也就是最开始MCP Host知道有哪些可用的工具与资源，我们在本 DEMO 中使用了硬编码的方式将资源信息构建在提示词中。<br>
这里需要注意的是MCP Client与MCP Host（主机）并不是分离的部分，但为了时序图清晰，这里将其逻辑上拆分为不同的部分，实际上MCP Host可以理解为我们需要嵌入AI的应用程序，例如 CRM 系统或 SaaS 服务，实际上Host中是包含MCP Client的代码。实际的 MCP Host 与 Client 结构如下图所示：<br>
<img src="mcp-7.png" alt=""></p>
<h1>搭建MCP Client应用</h1>
<h2 id="准备模型">准备模型</h2>
<p>准备一个适配<code>openai</code>协议的大模型<code>API</code>，例如：<code>deepseek V3</code>，<code>Qwen</code>系列，<code>Moonshot</code>月之暗面等等。<br>
为了编写<code>MCP Client</code>，首先在工程中创建环境变量<code>.env</code>文件，在该文件中我们放入自己的大模型相关信息，主要包含3个字段：</p>
<ol>
<li><code>OPENAI_API_KEY</code>：大模型的<code>API KEY</code></li>
<li><code>BASE_URL</code>：大模型请求地址</li>
<li><code>MODEL</code>：模型名称<br>
<img src="mcp-8.png" alt=""></li>
</ol>
<h2 id="MCP-Prompt">MCP-Prompt</h2>
<p>目前支持或深度集成<code>MCP</code>协议的大模型，主要包括：<strong>Claude系列</strong>和<strong>GPT系列</strong>等。<br>
国内的大模型供应商对于<code>MCP</code>协议基本上没有做针对性的集成训练，所以在国内使用<code>MCP</code>协议，必须编写结构化的<code>MCP-Prompt</code>，通过<code>system prompt</code>的方式让国内的大模型具备适配<code>MCP</code>协议。<br>
为了编写这个提示词，我使用<code>cloudflare</code>对大模型进行代理，然后对<code>Cursor</code>的<code>MCP</code>请求进行截获并将<code>MCP</code>提示词相关内容保留，其他无关内容删除，得到以下提示词，当然大家也可以自行对这个提示词进行修改，实现自己的定制化。<br>
在工程中创建文件<code>MCP_Prompt.txt</code>，将以下内容放入文件中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">You are an AI assistant, you can help users solve problems, including but not limited to programming, editing files, browsing websites, etc.</span><br><span class="line"></span><br><span class="line">====</span><br><span class="line"></span><br><span class="line">TOOL USE</span><br><span class="line"></span><br><span class="line">You have access to a set of tools that are executed upon the user&#x27;s approval. You can use one tool per message, and will receive the result of that tool use in the user&#x27;s response. You use tools step-by-step to accomplish a given task, with each tool use informed by the result of the previous tool use.</span><br><span class="line"></span><br><span class="line"># Tool Use Formatting</span><br><span class="line"></span><br><span class="line">Tool use is formatted using XML-style tags. The tool name is enclosed in opening and closing tags, and each parameter is similarly enclosed within its own set of tags. Here&#x27;s the structure:</span><br><span class="line"></span><br><span class="line">&lt;tool_name&gt;</span><br><span class="line">&lt;parameter1_name&gt;value1&lt;/parameter1_name&gt;</span><br><span class="line">&lt;parameter2_name&gt;value2&lt;/parameter2_name&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/tool_name&gt;</span><br><span class="line"></span><br><span class="line">For example:</span><br><span class="line"></span><br><span class="line">&lt;read_file&gt;</span><br><span class="line">&lt;path&gt;src/main.js&lt;/path&gt;</span><br><span class="line">&lt;/read_file&gt;</span><br><span class="line"></span><br><span class="line">Always adhere to this format for the tool use to ensure proper parsing and execution.</span><br><span class="line"></span><br><span class="line"># Tools</span><br><span class="line">## use_mcp_tool</span><br><span class="line">Description: Request to use a tool provided by a connected MCP server. Each MCP server can provide multiple tools with different capabilities. Tools have defined input schemas that specify required and optional parameters.</span><br><span class="line">Parameters:</span><br><span class="line">- server_name: (required) The name of the MCP server providing the tool</span><br><span class="line">- tool_name: (required) The name of the tool to execute</span><br><span class="line">- arguments: (required) A JSON object containing the tool&#x27;s input parameters, following the tool&#x27;s input schema</span><br><span class="line">Usage:</span><br><span class="line">&lt;use_mcp_tool&gt;</span><br><span class="line">&lt;server_name&gt;server name here&lt;/server_name&gt;</span><br><span class="line">&lt;tool_name&gt;tool name here&lt;/tool_name&gt;</span><br><span class="line">&lt;arguments&gt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;param1&quot;: &quot;value1&quot;,</span><br><span class="line">  &quot;param2&quot;: &quot;value2&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/arguments&gt;</span><br><span class="line">&lt;/use_mcp_tool&gt;</span><br><span class="line"></span><br><span class="line"># Tool Use Examples</span><br><span class="line">## Example 1: Requesting to use an MCP tool</span><br><span class="line"></span><br><span class="line">&lt;use_mcp_tool&gt;</span><br><span class="line">&lt;server_name&gt;weather-server&lt;/server_name&gt;</span><br><span class="line">&lt;tool_name&gt;get_forecast&lt;/tool_name&gt;</span><br><span class="line">&lt;arguments&gt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;city&quot;: &quot;San Francisco&quot;,</span><br><span class="line">  &quot;days&quot;: 5</span><br><span class="line">&#125;</span><br><span class="line">&lt;/arguments&gt;</span><br><span class="line">&lt;/use_mcp_tool&gt;</span><br><span class="line"></span><br><span class="line">## Example 2: Another example of using an MCP tool (where the server name is a unique identifier such as a URL)</span><br><span class="line"></span><br><span class="line">&lt;use_mcp_tool&gt;</span><br><span class="line">&lt;server_name&gt;github.com/modelcontextprotocol/servers/tree/main/src/github&lt;/server_name&gt;</span><br><span class="line">&lt;tool_name&gt;create_issue&lt;/tool_name&gt;</span><br><span class="line">&lt;arguments&gt;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;owner&quot;: &quot;octocat&quot;,</span><br><span class="line">  &quot;repo&quot;: &quot;hello-world&quot;,</span><br><span class="line">  &quot;title&quot;: &quot;Found a bug&quot;,</span><br><span class="line">  &quot;body&quot;: &quot;I&#x27;m having a problem with this.&quot;,</span><br><span class="line">  &quot;labels&quot;: [&quot;bug&quot;, &quot;help wanted&quot;],</span><br><span class="line">  &quot;assignees&quot;: [&quot;octocat&quot;]</span><br><span class="line">&#125;</span><br><span class="line">&lt;/arguments&gt;</span><br><span class="line">&lt;/use_mcp_tool&gt;</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line"></span><br><span class="line">MCP SERVERS</span><br><span class="line"></span><br><span class="line">The Model Context Protocol (MCP) enables communication between the system and locally running MCP servers that provide additional tools and resources to extend your capabilities.</span><br><span class="line"></span><br><span class="line"># Connected MCP Servers</span><br><span class="line"></span><br><span class="line">When a server is connected, you can use the server&#x27;s tools via the `use_mcp_tool` tool, and access the server&#x27;s resources via the `access_mcp_resource` tool.</span><br><span class="line">&lt;$MCP_INFO$&gt;</span><br><span class="line"></span><br><span class="line">===</span><br><span class="line"> </span><br><span class="line">CAPABILITIES</span><br><span class="line">- You have access to MCP servers that may provide additional tools and resources. Each server may provide different capabilities that you can use to accomplish tasks more effectively.</span><br><span class="line"></span><br><span class="line">====</span><br><span class="line"></span><br><span class="line">RULES</span><br><span class="line">- MCP operations should be used one at a time, similar to other tool usage. Wait for confirmation of success before proceeding with additional operations.</span><br><span class="line"></span><br><span class="line">====</span><br><span class="line"></span><br><span class="line">OBJECTIVE</span><br><span class="line"></span><br><span class="line">You accomplish a given task iteratively, breaking it down into clear steps and working through them methodically.</span><br><span class="line"></span><br><span class="line">1. Analyze the user&#x27;s task and set clear, achievable goals to accomplish it. Prioritize these goals in a logical order.</span><br><span class="line">2. Work through these goals sequentially, utilizing available tools one at a time as necessary. Each goal should correspond to a distinct step in your problem-solving process. You will be informed on the work completed and what&#x27;s remaining as you go.</span><br><span class="line">3. Once you&#x27;ve completed the user&#x27;s task, you must use the attempt_completion tool to present the result of the task to the user. </span><br><span class="line">4. The user may provide feedback, which you can use to make improvements and try again. But DO NOT continue in pointless back and forth conversations, i.e. don&#x27;t end your responses with questions or offers for further assistance.&quot;</span><br></pre></td></tr></table></figure>
<h2 id="引入MCP配置文件">引入MCP配置文件</h2>
<blockquote>
<p>提前搭建好mcp服务，搭建分为几部分：server、resources、tools、prompts，详细步骤可参考教程：<a href="https://github.com/modelcontextprotocol/typescript-sdk%EF%BC%8C">https://github.com/modelcontextprotocol/typescript-sdk，</a> 这里给出一个mcp-server示例： <a href="mcp-server-weather.ts">mcp-server-weather.ts</a></p>
</blockquote>
<p>一个客户端通常可以连接多个MCP服务，用过Cursor或其他MCP Client应用的同学应该很清楚，他们是通过一个JSON配置文件去加载多个MCP Server，我们也可以在客户端配置一个<code>mcp.json</code>文件去完成多个服务的配置和加载。<br>
<code>mcp.json</code>示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;mcpServers&quot;: &#123;</span><br><span class="line">        &quot;weather&quot;: &#123;</span><br><span class="line">            &quot;isActive&quot;: true,</span><br><span class="line">            &quot;type&quot;: &quot;stdio&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;weather&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;node&quot;,</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;E:\\work\\mcp-nodejs\\build\\server\\mcp-server-weather.js&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;amap-amap-sse&quot;: &#123;</span><br><span class="line">            &quot;isActive&quot;: true,</span><br><span class="line">            &quot;type&quot;: &quot;sse&quot;,</span><br><span class="line">            &quot;name&quot;: &quot;amap-amap-sse&quot;,</span><br><span class="line">            &quot;url&quot;: &quot;https://mcp.amap.com/sse?key=&#123;高德API KEY&#125;&quot; </span><br><span class="line">            /* &#123;高德API KEY&#125;可以去高德官网注册账号，可以免费获取 */</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字段意义如下所示：</p>
<ol>
<li>公共字段：</li>
</ol>
<ul>
<li><code>isActive</code>：用于控制该MCP Server是否被激活。</li>
<li><code>type</code>：MCP Server的类型，取值为stdio或sse</li>
<li><code>name</code>：MCP Server别名。</li>
</ul>
<ol start="2">
<li><code>stdio</code>相关字段：</li>
</ol>
<ul>
<li><code>command</code>：命令名称。</li>
<li><code>args</code>：参数列表</li>
<li><code>env</code>：环境变量字典</li>
</ul>
<ol start="3">
<li><code>sse</code>相关参数：</li>
</ol>
<ul>
<li><code>url</code>：SSE MCP Server服务地址</li>
</ul>
<h2 id="实现通信协议">实现通信协议</h2>
<p>MCP 为客户端-服务端通信定义了两种标准传输机制：</p>
<ul>
<li><code>stdio</code> 传输方式是最简单的通信方式，通常在本地工具之间进行消息传递时使用。它利用标准输入输出（stdin/stdout）作为数据传输通道，适用于本地进程间的交互。</li>
<li><code>SSE</code> 是基于 HTTP 协议的流式传输机制，它允许服务器通过 HTTP 单向推送事件到客户端。SSE 适用于客户端需要接收服务器推送的场景，通常用于实时数据更新</li>
</ul>
<p>我们以对话聊天的形式去实现mcp-client，大概流程如下：<br>
<img src="mcp-9.png" alt=""><br>
<code>mcp-client.ts</code>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123; Client &#125; from &quot;@modelcontextprotocol/sdk/client/index.js&quot;;</span><br><span class="line">import &#123; StdioClientTransport, StdioServerParameters &#125; from &quot;@modelcontextprotocol/sdk/client/stdio.js&quot;;</span><br><span class="line">import &#123; SSEClientTransport &#125; from &quot;@modelcontextprotocol/sdk/client/sse.js&quot;;</span><br><span class="line">import OpenAI from &quot;openai&quot;;</span><br><span class="line">import &#123; Tool &#125; from &quot;@modelcontextprotocol/sdk/types.js&quot;;</span><br><span class="line">import &#123; ChatCompletionMessageParam &#125; from &quot;openai/resources/chat/completions.js&quot;;</span><br><span class="line">import readline from &#x27;readline/promises&#x27;;</span><br><span class="line">import &#123; homedir &#125; from &#x27;os&#x27;;</span><br><span class="line">import path from &#x27;path&#x27;;</span><br><span class="line">import fs from &#x27;fs/promises&#x27;;</span><br><span class="line">import process from &#x27;process&#x27;;</span><br><span class="line">import dotenv from &quot;dotenv&quot;;</span><br><span class="line">dotenv.config();</span><br><span class="line"></span><br><span class="line">const API_KEY = process.env.API_KEY;</span><br><span class="line">const MODEL = process.env.MODEL;</span><br><span class="line">const BASE_URL = process.env.BASE_URL;</span><br><span class="line"></span><br><span class="line">// 添加对 MODEL 环境变量的检查</span><br><span class="line">if (!API_KEY || !MODEL || !BASE_URL) &#123;</span><br><span class="line">    throw new Error(&quot;MODEL environment variable is required&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// MCP 配置文件的类型定义</span><br><span class="line">interface McpConfig &#123;</span><br><span class="line">    mcpServers?: &#123;</span><br><span class="line">        [key: string]: &#123;</span><br><span class="line">            isActive?: boolean;</span><br><span class="line">            name?: string;</span><br><span class="line">            type: &#x27;stdio&#x27; | &#x27;sse&#x27;;</span><br><span class="line">            command?: string;</span><br><span class="line">            args?: string[];</span><br><span class="line">            env?: &#123; [key: string]: string &#125;;</span><br><span class="line">            url?: string;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export class McpClient &#123;</span><br><span class="line">    private sessions: Map&lt;string, Client&gt; = new Map(); // 存储会话</span><br><span class="line">    private transports: Map&lt;string, StdioClientTransport | SSEClientTransport&gt; = new Map(); // 存储 transport，用于清理资源</span><br><span class="line">    private openai: OpenAI;</span><br><span class="line">    private systemPrompt: string = &#x27;&#x27;;</span><br><span class="line">    // messages 存储完整的对话历史，包括 system, user, assistant, tool 消息</span><br><span class="line">    private messages: ChatCompletionMessageParam[] = [];</span><br><span class="line">    private promptFilePath = path.join(process.cwd(), &#x27;mcp_prompt.txt&#x27;);</span><br><span class="line"></span><br><span class="line">    constructor() &#123;</span><br><span class="line">        this.openai = new OpenAI(&#123;</span><br><span class="line">            apiKey: API_KEY,</span><br><span class="line">            baseURL: BASE_URL,</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 初始化方法，仅读取 prompt 文件</span><br><span class="line">    async initialize(): Promise&lt;void&gt; &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            const resolvedPromptPath = path.resolve(this.promptFilePath);</span><br><span class="line">            this.systemPrompt = await fs.readFile(resolvedPromptPath, &#x27;utf-8&#x27;);</span><br><span class="line">            console.log(`Successfully loaded system prompt from $&#123;resolvedPromptPath&#125;\n`);</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.error(`Error reading prompt file $&#123;this.promptFilePath&#125;:`, error);</span><br><span class="line">            // 如果读取失败，使用一个默认提示</span><br><span class="line">            this.systemPrompt = &#x27;You are an AI assistant. Respond to user queries.&#x27;;</span><br><span class="line">            console.warn(&#x27;Using a default system prompt due to file read error.&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现 MCP 配置加载和服务器连接逻辑</span><br><span class="line">    async loadConfigAndConnectServers(mcpJsonFile: string = &#x27;./mcp.json&#x27;): Promise&lt;void&gt; &#123;</span><br><span class="line">        let mcpConfig: McpConfig = &#123;&#125;;</span><br><span class="line">        try &#123;</span><br><span class="line">            const filePath = path.resolve(mcpJsonFile);</span><br><span class="line">            const fileContent = await fs.readFile(filePath, &#x27;utf-8&#x27;);</span><br><span class="line">            mcpConfig = JSON.parse(fileContent) as McpConfig;</span><br><span class="line"></span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.error(`Error reading or parsing MCP config file $&#123;mcpJsonFile&#125;:`, error);</span><br><span class="line">            // 在这里抛出错误，中断启动流程，因为没有配置无法连接服务器</span><br><span class="line">            throw new Error(`Failed to load MCP config: $&#123;error instanceof Error ? error.message : String(error)&#125;`);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const serversConfig = mcpConfig.mcpServers || &#123;&#125;;</span><br><span class="line">        let connectedCount = 0;</span><br><span class="line"></span><br><span class="line">        for (const k in serversConfig) &#123;</span><br><span class="line">            if (Object.prototype.hasOwnProperty.call(serversConfig, k)) &#123;</span><br><span class="line">                const v = serversConfig[k];</span><br><span class="line">                console.log(&#x27;-&#x27;.repeat(50)); // 分隔符</span><br><span class="line">                if (v.isActive === false) &#123;</span><br><span class="line">                    console.log(`Skipping inactive server: $&#123;k&#125;`);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const mcpName = v.name || k; // 使用 name 属性或键作为名称</span><br><span class="line">                const mcpType = v.type?.toLowerCase();</span><br><span class="line"></span><br><span class="line">                try &#123;</span><br><span class="line">                    let transport: StdioClientTransport | SSEClientTransport;</span><br><span class="line"></span><br><span class="line">                    if (mcpType === &#x27;stdio&#x27;) &#123;</span><br><span class="line">                        const command = v.command;</span><br><span class="line">                        const args = v.args || [];</span><br><span class="line">                        const env = v.env || &#123;&#125;;</span><br><span class="line">                        if (!command) &#123;</span><br><span class="line">                            throw new Error(`$&#123;mcpName&#125; command is empty.`);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 使用 createCommandTransport 创建 transport</span><br><span class="line">                        transport = await this.createCommandTransport(command, args, env);</span><br><span class="line">                    &#125; else if (mcpType === &#x27;sse&#x27;) &#123;</span><br><span class="line">                        const serverUrl = v.url;</span><br><span class="line">                        if (!serverUrl) &#123;</span><br><span class="line">                            throw new Error(`$&#123;mcpName&#125; server_url is empty.`);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 使用 createSSETransport 创建 transport</span><br><span class="line">                        transport = await this.createSSETransport(serverUrl);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        throw new Error(`$&#123;mcpName&#125; mcp type must be &#x27;stdio&#x27; or &#x27;sse&#x27;.`);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    // 使用 Client 类连接 transport</span><br><span class="line">                    const client = new Client(</span><br><span class="line">                        &#123;</span><br><span class="line">                            name: &quot;mcp-client&quot;,</span><br><span class="line">                            version: &quot;1.0.0&quot;</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            capabilities: &#123;</span><br><span class="line">                                prompts: &#123;&#125;,</span><br><span class="line">                                resources: &#123;&#125;,</span><br><span class="line">                                tools: &#123;&#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    );</span><br><span class="line"></span><br><span class="line">                    // 连接 transport</span><br><span class="line">                    await client.connect(transport);</span><br><span class="line"></span><br><span class="line">                    // 存储 session 和 transport</span><br><span class="line">                    this.sessions.set(mcpName, client);</span><br><span class="line">                    this.transports.set(mcpName, transport); // 存储 transport 用于清理</span><br><span class="line"></span><br><span class="line">                    // 列出可用工具并添加到 systemPrompt</span><br><span class="line">                    const response = await client.listTools();</span><br><span class="line">                    const availableTools = response.tools.map((tool: Tool) =&gt;</span><br><span class="line">                        `##$&#123;mcpName&#125;\n### Available Tools\n- $&#123;tool.name&#125;\n$&#123;tool.description&#125;\n$&#123;JSON.stringify(tool.inputSchema)&#125;`</span><br><span class="line">                    );</span><br><span class="line">                    // 将新的 MCP_INFO 插入到 systemPrompt 中第一个 &lt;$MCP_INFO$&gt; 的位置</span><br><span class="line">                    // 如果 systemPrompt 中没有占位符，replace 不会改变字符串</span><br><span class="line">                    this.systemPrompt = this.systemPrompt.replace(&#x27;&lt;$MCP_INFO$&gt;&#x27;, availableTools.join(&#x27;\n&#x27;) + &#x27;\n&lt;$MCP_INFO$&gt;&#x27;);</span><br><span class="line"></span><br><span class="line">                    console.log(`Successfully connected to $&#123;mcpName&#125; server with tools:`, response.tools.map((tool: Tool) =&gt; tool.name));</span><br><span class="line">                    connectedCount++;</span><br><span class="line"></span><br><span class="line">                &#125; catch (e) &#123;</span><br><span class="line">                    console.error(`Error connecting to $&#123;mcpName&#125;: $&#123;e instanceof Error ? e.message : String(e)&#125;`);</span><br><span class="line">                    // 不在此处抛出错误，允许连接其他服务器</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 在所有服务器连接尝试后，移除模板中剩余的 &lt;$MCP_INFO$&gt; 占位符</span><br><span class="line">        this.systemPrompt = this.systemPrompt.replace(/&lt;\$MCP_INFO\$&gt;/g, &#x27;&#x27;);</span><br><span class="line"></span><br><span class="line">        if (connectedCount === 0) &#123;</span><br><span class="line">            console.warn(&quot;No active MCP sessions established based on config.&quot;);</span><br><span class="line">            // 在这里抛出错误，中断启动流程，因为没有连接任何服务器就无法使用工具</span><br><span class="line">            throw new Error(&quot;Failed to connect to any active server based on config&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建 StdIO Transport，使用 command, args, env 参数与 mcpJsonConfig 中的 usage 匹配</span><br><span class="line">    private async createCommandTransport(command: string, args: string[], env: Record&lt;string, string&gt;): Promise&lt;StdioClientTransport&gt; &#123;</span><br><span class="line">        // 这里根据 mcp.json 的结构，直接使用 command, args, env 参数</span><br><span class="line">        if (!command) &#123;</span><br><span class="line">            throw new Error(&quot;Command is empty&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 处理 args 中的波浪号路径</span><br><span class="line">        const processedArgs = args.map(arg =&gt; &#123;</span><br><span class="line">            if (arg.startsWith(&#x27;~/&#x27;)) &#123;</span><br><span class="line">                return arg.replace(&#x27;~&#x27;, homedir());</span><br><span class="line">            &#125;</span><br><span class="line">            return arg;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        // 过滤 undefined 的环境变量</span><br><span class="line">        const processedEnv = Object.fromEntries(</span><br><span class="line">            Object.entries(env).filter(([_, v]) =&gt; v !== undefined)</span><br><span class="line">        ) as Record&lt;string, string&gt;;</span><br><span class="line"></span><br><span class="line">        const serverParams: StdioServerParameters = &#123;</span><br><span class="line">            command,</span><br><span class="line">            args: processedArgs,</span><br><span class="line">            env: processedEnv</span><br><span class="line">        &#125;;</span><br><span class="line">        return new StdioClientTransport(serverParams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建 SSE Transport</span><br><span class="line">    private async createSSETransport(url: string): Promise&lt;SSEClientTransport&gt; &#123;</span><br><span class="line">        // 直接使用传入的 url 参数</span><br><span class="line">        return new SSEClientTransport(new URL(url));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 解析 &lt;use_mcp_tool&gt; 标签，提取 server_name, tool_name 和 arguments</span><br><span class="line">    parseToolString(toolString: string): [string, string, any] &#123;</span><br><span class="line">        // 使用更精确的regex来匹配完整的&lt;use_mcp_tool&gt;块</span><br><span class="line">        const fullMatch = toolString.match(/&lt;use_mcp_tool&gt;([\s\S]*?)&lt;\/use_mcp_tool&gt;/);</span><br><span class="line">        if (!fullMatch || !fullMatch[1]) &#123;</span><br><span class="line">            // 如果完整匹配失败，尝试备用 regex (可能不够健壮)</span><br><span class="line">            const fallbackMatch = toolString.match(/&lt;use_mcp_tool&gt;([\s\S]*?)&lt;\/use_mcp_tool&gt;/s);</span><br><span class="line">            if (!fallbackMatch || !fallbackMatch[1]) &#123;</span><br><span class="line">                throw new Error(&#x27;未找到 &lt;use_mcp_tool&gt; 标签或标签为空&#x27;);</span><br><span class="line">            &#125;</span><br><span class="line">            toolString = fallbackMatch[1];</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            toolString = fullMatch[1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const serverNameMatch = toolString.match(/&lt;server_name&gt;([\s\S]*?)&lt;\/server_name&gt;/);</span><br><span class="line">        const toolNameMatch = toolString.match(/&lt;tool_name&gt;([\s\S]*?)&lt;\/tool_name&gt;/);</span><br><span class="line">        const argsMatch = toolString.match(/&lt;arguments&gt;([\s\S]*?)&lt;\/arguments&gt;/);</span><br><span class="line"></span><br><span class="line">        if (!serverNameMatch || !toolNameMatch || !argsMatch) &#123;</span><br><span class="line">            throw new Error(&#x27; &lt;use_mcp_tool&gt; 中缺少 server_name, tool_name 或 arguments 标签&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        const serverName = serverNameMatch[1].trim();</span><br><span class="line">        const toolName = toolNameMatch[1].trim();</span><br><span class="line">        let toolArgs;</span><br><span class="line">        try &#123;</span><br><span class="line">            toolArgs = JSON.parse(argsMatch[1].trim() || &#x27;&#123;&#125;&#x27;);</span><br><span class="line">        &#125; catch (e) &#123;</span><br><span class="line">            throw new Error(&#x27;工具参数无效: &#x27; + (e instanceof Error ? e.message : String(e)));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (!serverName || !toolName) &#123;</span><br><span class="line">            throw new Error(&#x27; server_name 或 tool_name 内容缺失&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return [serverName, toolName, toolArgs];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 查询处理逻辑</span><br><span class="line">    processQuery = async (query: string): Promise&lt;string | null&gt; =&gt; &#123;</span><br><span class="line">        this.messages.push(</span><br><span class="line">            &#123;</span><br><span class="line">                role: &#x27;system&#x27;,</span><br><span class="line">                content: this.systemPrompt</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line">        this.messages.push(</span><br><span class="line">            &#123;</span><br><span class="line">                role: &#x27;user&#x27;,</span><br><span class="line">                content: query</span><br><span class="line">            &#125;</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        // 首次调用 OpenAI API</span><br><span class="line">        const completion = await this.openai.chat.completions.create(&#123;</span><br><span class="line">            model: MODEL as string,</span><br><span class="line">            messages: this.messages,</span><br><span class="line">            max_tokens: 1024,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        let currentResponse = completion.choices[0].message.content;</span><br><span class="line"></span><br><span class="line">        // 检查响应是否包含工具调用标签</span><br><span class="line">        if (currentResponse &amp;&amp; currentResponse.includes(&#x27;&lt;use_mcp_tool&gt;&#x27;)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // 将 LLM 的回复添加到消息历史</span><br><span class="line">                this.messages.push(&#123;</span><br><span class="line">                    role: &#x27;assistant&#x27;,</span><br><span class="line">                    content: currentResponse</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">                // 解析工具调用信息</span><br><span class="line">                const [serverName, toolName, toolArgs] = this.parseToolString(currentResponse);</span><br><span class="line"></span><br><span class="line">                // 记录工具调用详情</span><br><span class="line">                console.log(`[Calling tool $&#123;toolName&#125; with args $&#123;JSON.stringify(toolArgs)&#125;]`);</span><br><span class="line">                console.log(&#x27;-&#x27;.repeat(40));</span><br><span class="line">                console.log(&quot;Server:&quot;, serverName);</span><br><span class="line">                console.log(&quot;Tool:&quot;, toolName);</span><br><span class="line">                console.log(&quot;Args:&quot;, JSON.stringify(toolArgs));</span><br><span class="line">                console.log(&#x27;-&#x27;.repeat(40));</span><br><span class="line"></span><br><span class="line">                // 调用工具</span><br><span class="line">                const session = this.sessions.get(serverName);</span><br><span class="line">                if (!session) &#123;</span><br><span class="line">                    const errorContent = `[错误: 服务器 $&#123;serverName&#125; 未连接或找不到工具 $&#123;toolName&#125;]`;</span><br><span class="line">                    console.error(errorContent);</span><br><span class="line">                    // 将错误消息作为用户消息添加到消息历史，供 LLM 处理</span><br><span class="line">                    this.messages.push(&#123;</span><br><span class="line">                        role: &#x27;user&#x27;,</span><br><span class="line">                        content: `[工具 $&#123;toolName&#125; 返回错误: $&#123;errorContent&#125;]`</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    const toolResult = await session.callTool(&#123; name: toolName, arguments: toolArgs &#125;);</span><br><span class="line"></span><br><span class="line">                    // 记录工具结果</span><br><span class="line">                    const toolResultText = toolResult.content ? JSON.stringify(toolResult.content) : &#x27;无内容&#x27;;</span><br><span class="line">                    console.log(&quot;Result:&quot;, toolResultText);</span><br><span class="line">                    console.log(&#x27;-&#x27;.repeat(40));</span><br><span class="line"></span><br><span class="line">                    // 将工具结果作为新的用户消息添加到消息历史</span><br><span class="line">                    this.messages.push(&#123;</span><br><span class="line">                        role: &#x27;user&#x27;,</span><br><span class="line">                        content: `[Tool $&#123;toolName&#125; returned: $&#123;toolResultText&#125;]` // 将工具结果内容 JSON 字符串化</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                // 使用更新后的消息进行第二次 API 调用</span><br><span class="line">                const secondCompletion = await this.openai.chat.completions.create(&#123;</span><br><span class="line">                    model: MODEL as string,</span><br><span class="line">                    messages: this.messages,</span><br><span class="line">                    max_tokens: 1024,</span><br><span class="line">                &#125;);</span><br><span class="line">                currentResponse = secondCompletion.choices[0].message.content;</span><br><span class="line"></span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">                console.error(&#x27;处理工具调用出错:&#x27;, error);</span><br><span class="line">                // 将错误消息作为用户消息添加到消息历史，供 LLM 处理</span><br><span class="line">                this.messages.push(&#123;</span><br><span class="line">                    role: &#x27;user&#x27;,</span><br><span class="line">                    content: `[工具调用失败: $&#123;error instanceof Error ? error.message : String(error)&#125;]`</span><br><span class="line">                &#125;);</span><br><span class="line">                // 使用错误消息进行第二次 API 调用</span><br><span class="line">                const secondCompletion = await this.openai.chat.completions.create(&#123;</span><br><span class="line">                    model: MODEL as string,</span><br><span class="line">                    messages: this.messages,</span><br><span class="line">                    max_tokens: 1024,</span><br><span class="line">                &#125;);</span><br><span class="line">                currentResponse = secondCompletion.choices[0].message.content;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return currentResponse; // 返回最终响应（首次或工具调用后）</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 聊天循环</span><br><span class="line">    chatLoop = async () =&gt; &#123;</span><br><span class="line">        console.log(&#x27;\nMCP Client Started!&#x27;);</span><br><span class="line">        console.log(&quot;Type your queries or &#x27;quit&#x27; to exit.&quot;);</span><br><span class="line"></span><br><span class="line">        const rl = readline.createInterface(&#123;</span><br><span class="line">            input: process.stdin,</span><br><span class="line">            output: process.stdout,</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            // 清空消息历史，只在循环开始前清空一次</span><br><span class="line">            this.messages = [];</span><br><span class="line">            while (true) &#123;</span><br><span class="line">                const query = await rl.question(&#x27;\nQuery: &#x27;);</span><br><span class="line"></span><br><span class="line">                if (query.toLowerCase() === &#x27;quit&#x27;) &#123;</span><br><span class="line">                    rl.close(); // 关闭 readline 接口</span><br><span class="line">                    break; // 退出循环</span><br><span class="line">                &#125;</span><br><span class="line">                if (query.trim() === &#x27;&#x27;) &#123;</span><br><span class="line">                    console.log(&quot;Please enter a query.&quot;);</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                const response = await this.processQuery(query);</span><br><span class="line"></span><br><span class="line">                // 打印最终响应</span><br><span class="line">                // Print the final response</span><br><span class="line">                console.log(&#x27;Answer:&#x27;, response);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (error) &#123;</span><br><span class="line">            console.error(&#x27;\nError:&#x27;, error);</span><br><span class="line"></span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            rl.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 清理资源</span><br><span class="line">    cleanup = async (): Promise&lt;void&gt; =&gt; &#123;</span><br><span class="line">        console.log(&quot;\nInitiating cleanup...&quot;);</span><br><span class="line">        // 遍历 transports 进行关闭</span><br><span class="line">        for (const transport of this.transports.values()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                await transport.close();</span><br><span class="line">                console.log(&quot;Closed transport.&quot;);</span><br><span class="line">            &#125; catch (error) &#123;</span><br><span class="line">                console.error(&quot;Error closing transport:&quot;, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.transports.clear();</span><br><span class="line">        this.sessions.clear();</span><br><span class="line">        console.log(&quot;Cleanup complete.&quot;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 检查是否有活动的会话</span><br><span class="line">    hasActiveSessions(): boolean &#123;</span><br><span class="line">        return this.sessions.size &gt; 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 主函数</span><br><span class="line">async function main() &#123;</span><br><span class="line">    const client = new McpClient();</span><br><span class="line">    const mcpConfigFile = path.join(process.cwd(), &#x27;mcp.json&#x27;);</span><br><span class="line">    try &#123;</span><br><span class="line">        // 1. 初始化客户端（读取 prompt 文件）</span><br><span class="line">        await client.initialize();</span><br><span class="line"></span><br><span class="line">        // 2. 加载配置并连接服务器</span><br><span class="line">        await client.loadConfigAndConnectServers(mcpConfigFile);</span><br><span class="line"></span><br><span class="line">        // 3. 只有在成功连接至少一个服务器时才启动聊天循环</span><br><span class="line">        if (!client.hasActiveSessions()) &#123;</span><br><span class="line">            console.error(&quot;未建立任何活动的 MCP 会话。正在退出。&quot;);</span><br><span class="line">            // 即使没有连接服务器，也调用 cleanup 确保 readline 等资源被释放</span><br><span class="line">            await client.cleanup();</span><br><span class="line">            process.exit(1); // 以非零状态码退出表示错误</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 4. 启动聊天循环</span><br><span class="line">        await client.chatLoop();</span><br><span class="line"></span><br><span class="line">    &#125; catch (error) &#123;</span><br><span class="line">        // 捕获初始化或加载配置阶段可能发生的错误</span><br><span class="line">        console.error(&#x27;初始化、配置加载或运行时错误:&#x27;, error);</span><br><span class="line">        // 确保在发生错误时也执行清理</span><br><span class="line">        await client.cleanup();</span><br><span class="line">        process.exit(1); // 以非零状态码退出表示错误</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        await client.cleanup();</span><br><span class="line">        process.exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(console.error);</span><br></pre></td></tr></table></figure>
<p>效果如图：<br>
<img src="mcp-10.png" alt=""></p>
<p>总结：现在已经实现了MCP Client的搭建，通过加载mcp.json配置文件，即可加载所有的MCP Server，通过验证所有的MCP Server都可以加载成功。</p>
<blockquote>
<p>参考：<br>
使用JsNode搭建MCP-Client：<br>
<a href="https://zhuanlan.zhihu.com/p/30869685315">https://zhuanlan.zhihu.com/p/30869685315</a><br>
<a href="https://zhuanlan.zhihu.com/p/1891179397081448675">https://zhuanlan.zhihu.com/p/1891179397081448675</a><br>
了解MCP与LLM之间的交互过程和日志：<br>
<a href="https://blog.chengchao.name/2025/04/03/write-a-sample-mcp-client/">https://blog.chengchao.name/2025/04/03/write-a-sample-mcp-client/</a><br>
从0开始搭建MCP-Server和MCP-Client教程：<br>
<a href="https://blog.minglog.cn/2025/04/18/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0MCP-Server/">https://blog.minglog.cn/2025/04/18/从0开始实现MCP-Server/</a><br>
<a href="https://blog.minglog.cn/2025/04/21/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0MCP-Client/">https://blog.minglog.cn/2025/04/21/从0开始实现MCP-Client/</a><br>
<a href="https://platform.moonshot.cn/console/api-keys">https://platform.moonshot.cn/console/api-keys</a><br>
理解MCP生命周期：<br>
<a href="https://www.cnblogs.com/CareySon/p/18827525/mcp_lifecycle_via_demo">https://www.cnblogs.com/CareySon/p/18827525/mcp_lifecycle_via_demo</a></p>
</blockquote>
<p align = "center">    
<img  src="nanie.jpg" width="200" />
</p>
]]></content>
      <categories>
        <category>ai</category>
      </categories>
      <tags>
        <tag>ai</tag>
      </tags>
  </entry>
</search>
